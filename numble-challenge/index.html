<!DOCTYPE html><html><head><meta charSet="utf-8"/><meta http-equiv="x-ua-compatible" content="ie=edge"/><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"/><meta name="generator" content="Gatsby 4.8.0"/><title data-react-helmet="true"></title><style>.gatsby-image-wrapper{position:relative;overflow:hidden}.gatsby-image-wrapper picture.object-fit-polyfill{position:static!important}.gatsby-image-wrapper img{bottom:0;height:100%;left:0;margin:0;max-width:none;padding:0;position:absolute;right:0;top:0;width:100%;object-fit:cover}.gatsby-image-wrapper [data-main-image]{opacity:0;transform:translateZ(0);transition:opacity .25s linear;will-change:opacity}.gatsby-image-wrapper-constrained{display:inline-block;vertical-align:top}</style><noscript><style>.gatsby-image-wrapper noscript [data-main-image]{opacity:1!important}.gatsby-image-wrapper [data-placeholder-image]{opacity:0!important}</style></noscript><script type="module">const e="undefined"!=typeof HTMLImageElement&&"loading"in HTMLImageElement.prototype;e&&document.body.addEventListener("load",(function(e){if(void 0===e.target.dataset.mainImage)return;if(void 0===e.target.dataset.gatsbyImageSsr)return;const t=e.target;let a=null,n=t;for(;null===a&&n;)void 0!==n.parentNode.dataset.gatsbyImageWrapper&&(a=n.parentNode),n=n.parentNode;const o=a.querySelector("[data-placeholder-image]"),r=new Image;r.src=t.currentSrc,r.decode().catch((()=>{})).then((()=>{t.style.opacity=1,o&&(o.style.opacity=0,o.style.transition="opacity 500ms linear")}))}),!0);</script><link as="script" rel="preload" href="/webpack-runtime-e0bfc4c4a39afd6169d6.js"/><link as="script" rel="preload" href="/framework-6bdc9aaa9caa3de6408b.js"/><link as="script" rel="preload" href="/app-f34191c66d70ce0253b2.js"/><link as="script" rel="preload" href="/component---src-templates-post-tsx-268e05f5ac4790150225.js"/><link as="fetch" rel="preload" href="/page-data/numble-challenge/page-data.json" crossorigin="anonymous"/><link as="fetch" rel="preload" href="/page-data/app-data.json" crossorigin="anonymous"/></head><body><div id="___gatsby"><div style="outline:none" tabindex="-1" id="gatsby-focus-wrapper"><style data-emotion="css 8ugl6e">.css-8ugl6e{display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-flex-direction:column;-ms-flex-direction:column;flex-direction:column;min-height:100vh;background-color:#121212;color:white;}.css-8ugl6e::-webkit-scrollbar-thumb{background-color:#ffffff;}</style><div class="css-8ugl6e ef79xez0"><style data-emotion="css-global 1llifsc">@import url(http://fonts.googleapis.com/css?family=Open+Sans:300italic,300);*{padding:0;margin:0;box-sizing:border-box;font-family:'Open Sans',Helvetica,sans-serif;font-weight:300;}html,body,#___gatsby{height:100%;}a,a:hover{color:inherit;-webkit-text-decoration:none;text-decoration:none;cursor:pointer;}</style><style data-emotion="css z5i94e">.css-z5i94e{position:relative;width:100%;height:350px;}</style><div class="css-z5i94e evp6fv50"><style data-emotion="css 1cf6hsn">.css-1cf6hsn{display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-flex-direction:column;-ms-flex-direction:column;flex-direction:column;width:768px;height:100%;margin:0 auto;padding:60px 0;color:#ffffff;}</style><div class="css-1cf6hsn e1x0sffc2"><style data-emotion="css 1pr6csa">.css-1pr6csa{overflow:hidden;overflow-wrap:break-word;margin-top:auto;text-overflow:ellipsis;white-space:normal;font-size:45px;font-weight:800;}</style><div class="css-1pr6csa e1x0sffc1">[React] 다른 색깔 찾기 게임 제작 챌린지</div><style data-emotion="css 15xrm5i">.css-15xrm5i{display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-flex-direction:column;-ms-flex-direction:column;flex-direction:column;-webkit-box-pack:start;-ms-flex-pack:start;-webkit-justify-content:flex-start;justify-content:flex-start;-webkit-box-pack:justify;-webkit-justify-content:space-between;justify-content:space-between;font-size:18px;font-weight:700;}.css-15xrm5i div{margin-top:10px;}</style><div class="css-15xrm5i e1x0sffc0"><div>2022.02.11.</div><div>React</div></div></div></div><style data-emotion="css n1la39">.css-n1la39{display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-flex-direction:column;-ms-flex-direction:column;flex-direction:column;width:768px;margin:0 auto;word-break:break-all;line-height:1.8;font-size:1.125rem;font-weight:400;color:#ececec;}.css-n1la39 p{padding:3px 0;}.css-n1la39 h1,.css-n1la39 h2,.css-n1la39 h3,.css-n1la39 h4{margin:2.414rem 0 1rem;font-weight:inherit;line-height:1.42;}.css-n1la39 h1{font-size:3.598rem;}.css-n1la39 h2{font-size:2.827rem;}.css-n1la39 h3{font-size:1.999rem;}.css-n1la39 h4{font-size:1.414rem;}.css-n1la39 h5{font-size:1.121rem;}.css-n1la39 h6{font-size:0.88rem;}.css-n1la39 blockquote{margin:10px 0;border-left:5px solid #7a7a7a;font-style:italic;padding:5px 15px;text-align:left;background-color:#1e1e1e;}.css-n1la39 aside{background-color:#1e1e1e;margin:10px 0;}.css-n1la39 table{background-color:#22272e;border-collapse:collapse;}.css-n1la39 table th,.css-n1la39 table td{padding:6px 13px;}.css-n1la39 table th:not(first-child),.css-n1la39 table td:not(first-child){border:1px solid #444c56;}.css-n1la39 ol,.css-n1la39 ul{margin-left:20px;padding:10px 0;}.css-n1la39 hr{margin:30px 0;background:#4d4d4d;border:none;height:1px;width:100%;}.css-n1la39 a:link{-webkit-text-decoration:none;text-decoration:none;text-shadow:0 0 24px;}.css-n1la39 a:hover{color:#4263eb;}.css-n1la39 strong{font-weight:bold;}.css-n1la39 deckgo-highlight-code{font-size:14px;}</style><div class="css-n1la39 era8a5j0"><h1>💎 결과물</h1>
<blockquote>
<p><a href="https://numble-challenge-six.vercel.app/" target="_blank" rel="nofollow">배포 링크</a> <br /> > <a href="https://github.com/seongjunme/numble-challenge" target="_blank" rel="nofollow">프로젝트 저장소</a></p>
</blockquote>
<hr>
<h1>🏅 Numble-Challenge</h1>
<blockquote>
<p><a href="https://www.numble.it/45cee9d3-49ad-4f67-9d2a-14607c2eeba7?fbclid=IwAR0SSpuIgY6jsrrDDkS327GS81uMtTIpMYKY0XBVJpUJ2SizvHnzGB_zlm8_aem_ASgeZPycnHtfst22zVLQZWnG3S_aGlAuktYloa9sZMYerAB5psRNPnpiQQNV-R3RKQDBmQU2RJ2bxk7PrY3m_rd4dh-qigKADasbXPeN08QCGX67bsGsCJQ-nawwkmrQF0c" target="_blank" rel="nofollow">챌린지 바로가기</a></p>
</blockquote>
<h2>📝 요구 사항</h2>
<p><img src="https://images.velog.io/images/jun_/post/a1378a60-6bf6-4b66-b618-dc2347d65d77/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA%202022-02-11%20%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE%207.20.32.png" alt=""></p>
<h2>📝 상세 스펙</h2>
<p><img src="https://images.velog.io/images/jun_/post/17d1b6ba-171e-4524-be34-dfe745e24011/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA%202022-02-11%20%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE%207.20.17.png" alt=""></p>
<hr>
<h1>🛠 사용 기술</h1>
<ul>
<li>React (hooks)</li>
<li>TypeScript</li>
<li>Styled-components</li>
<li>CRA</li>
<li>Vercel (deloy)</li>
</ul>
<hr>
<h1>👨🏻‍💻 주요 코드</h1>
<h2>상태 관리</h2>
<br />
<deckgo-highlight-code language="javascript" terminal="carbon"  >
          <code slot="code">function App() {
  const [state, dispatch] = useReducer(reducer, {
    isPlaying: true,
    stage: 1,
    time: TIME_PER_STAGE,
    score: 0,
    isClear: false,
  });

  const { isPlaying, stage, time, score, isClear } = state;
}</code>
        </deckgo-highlight-code>
<br />
<p>기본적으로 최상단 컴포넌트인 App에서 stage, time, score 등 주요 상태를 정의한다.
time 같은 경우는 커스텀 훅이나 컴포넌트로 분리할까 했지만, score 증가 로직에 time 값이 영향을 주기 때문에 항상 time이 최신값으로 유지되어야 해서 dependency가 발생했다. 그래서 최상단에서 time 상태를 정의하게 되었다. 이 문제는 바로 아래에서 더 자세히 설명한다.</p>
<br />
<deckgo-highlight-code language="jsx" terminal="carbon"  >
          <code slot="code">function App() {
  ...

  const goNextStage = useCallback(() =&gt; {
    dispatch({ type: &#39;STAGE_UP&#39; });
  }, []);

  const decreaseTime = useCallback(() =&gt; {
    dispatch({ type: &#39;WRONG_ANSWER&#39; });
  }, []);

  return (
      &lt;&gt;
        &lt;header&gt;스테이지: {stage}, 남은 시간: {time}, 점수: {score}&lt;/header&gt;
        &lt;Board stage={stage} handleAnswer={goNextStage} handleWrongAnswer={decreaseTime} /&gt;
      &lt;/&gt;
  )
}</code>
        </deckgo-highlight-code>
<br />
<p>App에서 렌더링하는 Board 컴포넌트의 경우 useMemo를 이용하여 Props가 변경되지 않으면 리렌더링이 되지 않도록 하였다. goNextStage 메소드에서 발생시키는 dispatch는 stage 증가와, 남은 time 값에 따른 score 증가를 수행한다. 이때 stage와 time 값의 변경은 비동기처리를 고려하여 콜백 인자 값으로 최신 상태가 전달된다. 하지만 time을 외부 값(Time을 담당하는 하위 컴포넌트 또는 커스텀 훅)으로 받게되면 goNextStage에 time dependency가 발생하게 되어 time이 실시간으로 변경될 때마다 goNextStage함수가 재 선언되고, 이로 인해 Board 컴포넌트가 리렌더링되어 색깔이 매 초마다 변경되는 현상이 발생되었다.</p>
<p>하지만 time을 분리시켜도 위 문제를 해결할 수 있는 방법이 있을 것이 분명하니 좀 더 고민이 필요해보인다.</p>
<br />
<h2>타이머</h2>
<br />
<deckgo-highlight-code language="javascript" terminal="carbon"  >
          <code slot="code">  const timer: { current: NodeJS.Timeout | null } = useRef(null);

  useEffect(() =&gt; {
    const countDown = () =&gt; {
      if (isPlaying) {
        dispatch({ type: &#39;COUNT_DOWN&#39; });
      }
      if (!(isPlaying || isClear)) {
        alert(`GAME OVER!\n스테이지: ${stage}, 점수: ${score}`);
        dispatch({ type: &#39;RESTART&#39; });
      }
    };

    timer.current = setInterval(countDown, 1000);

    return () =&gt; {
      clearTimeout(timer.current as NodeJS.Timeout);
    };
  }, [isPlaying, score, stage, isClear]);

  useEffect(() =&gt; {
    if (time &gt; 0) return;
    clearTimeout(timer.current as NodeJS.Timeout);
    dispatch({ type: &#39;GAME_OVER&#39; });
  }, [time]);</code>
        </deckgo-highlight-code>
<br />
<p>렌더링 초기에 타이머를 등록한다.
time 값이 변경될 때마다 time 값이 0이하인지 체크하게 되고, 0이하면 타이머를 종료시키고 GAME OVER 이벤트를 발생시킨다.
GAME OVER는 isPlaying 상태를 false로 변경하게 된다.</p>
<p>isPlaying이 false가 되면 alert로 종료 메시지를 보내고 사용자의 응답을 받으면 RESTART를 발생한다.</p>
<br />
<h2>블록 렌더링</h2>
<br />
<deckgo-highlight-code language="jsx" terminal="carbon"  >
          <code slot="code">const Board = ({ stage, handleAnswer, handleWrongAnswer }: Props) =&gt; {
  const renderBlock = () =&gt; {
    const blocks = [];
    const blockCount = Math.pow(Math.round((stage + 0 / 5) / 2) + 1, 2);
    const blockSize = BOARD_SIZE / Math.sqrt(blockCount);
    const blockColor = {
      r: getRandom(MAX_STAGE, 255),
      g: getRandom(MAX_STAGE, 255),
      b: getRandom(MAX_STAGE, 255),
    };
    const diffTarget = getRandom(0, blockCount - 1);

    for (let i = 0; i &lt; blockCount; i++) {
      if (i === diffTarget) {
        const diffColor = {
          r: blockColor.r - (MAX_STAGE - stage),
          g: blockColor.g - (MAX_STAGE - stage),
          b: blockColor.b - (MAX_STAGE - stage),
        };

        blocks.push(&lt;Block key={i} blockSize={blockSize} rgb={diffColor} onClickHandler={handleAnswer} /&gt;);
      } else {
        blocks.push(&lt;Block key={i} blockSize={blockSize} rgb={blockColor} onClickHandler={handleWrongAnswer} /&gt;);
      }
    }
    return blocks;
  };

  return &lt;Layout&gt;{renderBlock()}&lt;/Layout&gt;;
};</code>
        </deckgo-highlight-code>
<br />
<p>앞선 코드에서 보았듯이 App에서 Board 컴포넌트에게 Props로 stage를 준다.
Board 컴포넌트는 전달받은 stage에 따라 Block들을 렌더링한다.
블럭 중 정답 색상은 스테이지가 올라갈수록 차이를 감소시키기 위해 rgb 값에 각각
<code class="language-text">최대 스테이지 - 현재 스테이지</code> 의 차이를 주었다.
그리고 rgb 값이 음수로 떨어지지 않게 하기위해 blockColor(기본)는 최대 스테이지 값 부터 랜덤으로 선택하게 했다.</p>
<p>그리고 정답 블록을 랜덤으로 선택하여 rgb값과 onClickHandler값을 다르게 전달했다.</p>
<br />
<deckgo-highlight-code language="jsx" terminal="carbon"  >
          <code slot="code">const Block = ({ blockSize, rgb, onClickHandler }: Props) =&gt; {
  return &lt;Layout blockSize={blockSize} rgb={rgb} onClick={onClickHandler} /&gt;;
};</code>
        </deckgo-highlight-code>
<br />
<p>그리고 각 Block을 클릭하면 등록된 handler가 실행된다.</p></div><style data-emotion="css jppgbf">.css-jppgbf{display:grid;place-items:center;margin-top:auto;padding:3.125rem 0;font-size:0.9375rem;text-align:center;line-height:1.5;}</style><div class="css-jppgbf evi8j960">Thank You for Visiting My Blog, Have a Good Day.<br/>@ 2022 Developer Jun, Powerd By Gatsby.</div></div></div><div id="gatsby-announcer" style="position:absolute;top:0;width:1px;height:1px;padding:0;overflow:hidden;clip:rect(0, 0, 0, 0);white-space:nowrap;border:0" aria-live="assertive" aria-atomic="true"></div></div><script id="gatsby-script-loader">/*<![CDATA[*/window.pagePath="/numble-challenge/";window.___webpackCompilationHash="f063eb4cbaa6c8e2e10d";/*]]>*/</script><script id="gatsby-chunk-mapping">/*<![CDATA[*/window.___chunkMapping={"polyfill":["/polyfill-4718f0fec20e0d09d7f5.js"],"app":["/app-f34191c66d70ce0253b2.js"],"component---src-pages-404-tsx":["/component---src-pages-404-tsx-5a1562b048caf7768ff8.js"],"component---src-pages-blog-tsx":["/component---src-pages-blog-tsx-892c8a8d330fbfc194c0.js"],"component---src-pages-index-tsx":["/component---src-pages-index-tsx-def145fc02d2de2741cd.js"],"component---src-templates-post-tsx":["/component---src-templates-post-tsx-268e05f5ac4790150225.js"]};/*]]>*/</script><script src="/polyfill-4718f0fec20e0d09d7f5.js" nomodule=""></script><script src="/component---src-templates-post-tsx-268e05f5ac4790150225.js" async=""></script><script src="/app-f34191c66d70ce0253b2.js" async=""></script><script src="/framework-6bdc9aaa9caa3de6408b.js" async=""></script><script src="/webpack-runtime-e0bfc4c4a39afd6169d6.js" async=""></script></body></html>