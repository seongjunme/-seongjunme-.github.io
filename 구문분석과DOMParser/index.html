<!DOCTYPE html><html><head><meta charSet="utf-8"/><meta http-equiv="x-ua-compatible" content="ie=edge"/><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"/><meta name="generator" content="Gatsby 4.8.0"/><title data-react-helmet="true"></title><style>.gatsby-image-wrapper{position:relative;overflow:hidden}.gatsby-image-wrapper picture.object-fit-polyfill{position:static!important}.gatsby-image-wrapper img{bottom:0;height:100%;left:0;margin:0;max-width:none;padding:0;position:absolute;right:0;top:0;width:100%;object-fit:cover}.gatsby-image-wrapper [data-main-image]{opacity:0;transform:translateZ(0);transition:opacity .25s linear;will-change:opacity}.gatsby-image-wrapper-constrained{display:inline-block;vertical-align:top}</style><noscript><style>.gatsby-image-wrapper noscript [data-main-image]{opacity:1!important}.gatsby-image-wrapper [data-placeholder-image]{opacity:0!important}</style></noscript><script type="module">const e="undefined"!=typeof HTMLImageElement&&"loading"in HTMLImageElement.prototype;e&&document.body.addEventListener("load",(function(e){if(void 0===e.target.dataset.mainImage)return;if(void 0===e.target.dataset.gatsbyImageSsr)return;const t=e.target;let a=null,n=t;for(;null===a&&n;)void 0!==n.parentNode.dataset.gatsbyImageWrapper&&(a=n.parentNode),n=n.parentNode;const o=a.querySelector("[data-placeholder-image]"),r=new Image;r.src=t.currentSrc,r.decode().catch((()=>{})).then((()=>{t.style.opacity=1,o&&(o.style.opacity=0,o.style.transition="opacity 500ms linear")}))}),!0);</script><link as="script" rel="preload" href="/webpack-runtime-c0e03c5deb701c4aedb9.js"/><link as="script" rel="preload" href="/framework-6bdc9aaa9caa3de6408b.js"/><link as="script" rel="preload" href="/app-f34191c66d70ce0253b2.js"/><link as="script" rel="preload" href="/component---src-templates-post-tsx-cdd982b2742c5fa0a328.js"/><link as="fetch" rel="preload" href="/page-data/구문분석과DOMParser/page-data.json" crossorigin="anonymous"/><link as="fetch" rel="preload" href="/page-data/app-data.json" crossorigin="anonymous"/></head><body><div id="___gatsby"><div style="outline:none" tabindex="-1" id="gatsby-focus-wrapper"><style data-emotion="css rmgwh1">.css-rmgwh1{display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-flex-direction:column;-ms-flex-direction:column;flex-direction:column;height:100%;background-color:#121212;color:white;}.css-rmgwh1::-webkit-scrollbar-thumb{background-color:#ffffff;}</style><div class="css-rmgwh1 ef79xez0"><style data-emotion="css-global 1llifsc">@import url(http://fonts.googleapis.com/css?family=Open+Sans:300italic,300);*{padding:0;margin:0;box-sizing:border-box;font-family:'Open Sans',Helvetica,sans-serif;font-weight:300;}html,body,#___gatsby{height:100%;}a,a:hover{color:inherit;-webkit-text-decoration:none;text-decoration:none;cursor:pointer;}</style><style data-emotion="css z5i94e">.css-z5i94e{position:relative;width:100%;height:350px;}</style><div class="css-z5i94e evp6fv50"><style data-emotion="css 1cf6hsn">.css-1cf6hsn{display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-flex-direction:column;-ms-flex-direction:column;flex-direction:column;width:768px;height:100%;margin:0 auto;padding:60px 0;color:#ffffff;}</style><div class="css-1cf6hsn e1x0sffc2"><style data-emotion="css 1pr6csa">.css-1pr6csa{overflow:hidden;overflow-wrap:break-word;margin-top:auto;text-overflow:ellipsis;white-space:normal;font-size:45px;font-weight:800;}</style><div class="css-1pr6csa e1x0sffc1">구문 분석과 DOM Parser</div><style data-emotion="css 15xrm5i">.css-15xrm5i{display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-flex-direction:column;-ms-flex-direction:column;flex-direction:column;-webkit-box-pack:start;-ms-flex-pack:start;-webkit-justify-content:flex-start;justify-content:flex-start;-webkit-box-pack:justify;-webkit-justify-content:space-between;justify-content:space-between;font-size:18px;font-weight:700;}.css-15xrm5i div{margin-top:10px;}</style><div class="css-15xrm5i e1x0sffc0"><div>2021.07.27.</div><div>Node.js / 크롤링</div></div></div></div><style data-emotion="css n1la39">.css-n1la39{display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-flex-direction:column;-ms-flex-direction:column;flex-direction:column;width:768px;margin:0 auto;word-break:break-all;line-height:1.8;font-size:1.125rem;font-weight:400;color:#ececec;}.css-n1la39 p{padding:3px 0;}.css-n1la39 h1,.css-n1la39 h2,.css-n1la39 h3,.css-n1la39 h4{margin:2.414rem 0 1rem;font-weight:inherit;line-height:1.42;}.css-n1la39 h1{font-size:3.598rem;}.css-n1la39 h2{font-size:2.827rem;}.css-n1la39 h3{font-size:1.999rem;}.css-n1la39 h4{font-size:1.414rem;}.css-n1la39 h5{font-size:1.121rem;}.css-n1la39 h6{font-size:0.88rem;}.css-n1la39 blockquote{margin:10px 0;border-left:5px solid #7a7a7a;font-style:italic;padding:5px 15px;text-align:left;background-color:#1e1e1e;}.css-n1la39 aside{background-color:#1e1e1e;margin:10px 0;}.css-n1la39 table{background-color:#22272e;border-collapse:collapse;}.css-n1la39 table th,.css-n1la39 table td{padding:6px 13px;}.css-n1la39 table th:not(first-child),.css-n1la39 table td:not(first-child){border:1px solid #444c56;}.css-n1la39 ol,.css-n1la39 ul{margin-left:20px;padding:10px 0;}.css-n1la39 hr{margin:30px 0;background:#4d4d4d;border:none;height:1px;width:100%;}.css-n1la39 a:link{-webkit-text-decoration:none;text-decoration:none;text-shadow:0 0 24px;}.css-n1la39 a:hover{color:#4263eb;}.css-n1la39 strong{font-weight:bold;}.css-n1la39 deckgo-highlight-code{font-size:14px;}</style><div class="css-n1la39 era8a5j0"><h1>1. 구문 분석</h1>
<hr>
<p>컴파일러 이론에서 구문 북석을 하기 위해 사용하는 Tokenizer, Lexer, Parser를 알아보자.</p>
<h3>1.1 Tokenizer</h3>
<hr>
<p>Tokenizer란 어떤 구문에서 의미있을 법한 요소들을 token으로 쪼개어 나누는 역할을 한다.</p>
<p>아래의 경우는 배열을 , 단위로 토큰을 나눈 것이다.</p>
<deckgo-highlight-code language="jsx" terminal="carbon"  >
          <code slot="code">const arr = [&#39;1&#39;, &#39;[2, [3]]&#39;, &#39;seong&#39;, jun&#39;];

console.log(Tokenizer(arr));

//result
[&#39;1&#39;, &#39;[2, [3]]&#39;, &#39;seong&#39;, jun&#39;]</code>
        </deckgo-highlight-code>
<h3>1.2 Lexer</h3>
<hr>
<p>Lexer란 쪼갠 토큰을 이용하여 어휘를 분석한다.</p>
<p>아래의 경우 a, p, p, l, e 문자를 따로 읽으면 특별한 의미가 없지만, 붙여서 읽으면 apple이라는 어휘가 된다.</p>
<deckgo-highlight-code language="jsx" terminal="carbon"  >
          <code slot="code">const arr = [&#39;a&#39;, &#39;p&#39;, &#39;p&#39;, &#39;l&#39;, &#39;e&#39;];
console.log(Lexer(arr));

//result
apple;</code>
        </deckgo-highlight-code>
<p>그리고 위에서 토큰화 된 배열을 Lexer에 넣으면 아래와 같이 각각의 토큰을 분석해준다.</p>
<deckgo-highlight-code language="jsx" terminal="carbon"  >
          <code slot="code">const arr = [&#39;1&#39;, &#39;[2, [3]]&#39;, &#39;seong&#39;, &#39;jun&#39;];

console.log(Lexer(Tokenizer(arr)));

//result
[
	{ type: number, value = 1 },
	{ type: array, value = [2, [3]] },
	{ type: string, value = seong },
	{ type: string, value = jun },
]</code>
        </deckgo-highlight-code>
<h3>1.3 Parser</h3>
<hr>
<p>그리고 Parser는 분석한 Lexer의 결과를 이용해 하나의 AST(Abstract Syntax Tree) 구조로 변환해준다.</p>
<p><a href="https://user-images.githubusercontent.com/72444675/157590806-9f87e37d-92ac-4ecb-87d0-4557b7682047.png" target="_blank" rel="nofollow">400px-Abstract_syntax_tree_for_Euclidean_algorithm svg</a></p>
<p>출처: <a href="https://ko.wikipedia.org/wiki/%EC%B6%94%EC%83%81_%EA%B5%AC%EB%AC%B8_%ED%8A%B8%EB%A6%AC" target="_blank" rel="nofollow">https://ko.wikipedia.org/wiki/추상<em>구문</em>트리</a></p>
<p>HTML로 변환 예를 들면 다음과 같은 결과가 나온다.</p>
<deckgo-highlight-code language="jsx" terminal="carbon"  >
          <code slot="code">{
  element: &#39;HTML&#39;,
  attributes: [ { name: &#39;lang&#39;, value: &#39;&quot;ko&quot;&#39; } ],
  children: [
    {
      element: &#39;BODY&#39;,
      children: [
        {
          element: &#39;P&#39;,
          text: &#39;BOOST&#39;,
          children: [
            {
              element: &#39;IMG&#39;,
              attributes: [ { name: &#39;SRC&#39;, value: &#39;&quot;codesquad.kr&quot;&#39; } ]
            },
            { element: &#39;BR&#39; }
          ]
        }
      ]
    }
  ]
}</code>
        </deckgo-highlight-code>
<h1>2. DOM Parser</h1>
<hr>
<h2>2.1 DOM 이란?</h2>
<hr>
<blockquote>
<p>문서 객체 모델(Document Object Model)은 HTML, XML 문서의 프로그래밍 interface이다. DOM은 문서의 구조화된 표현을 제공하며 프로그래밍 언어가 DOM 구조에 접근할 수 있는 방법을 제공하여 그들이 문서 구조, 스타일, 내용 등을 변경할 수 있게 돕는다.</p>
</blockquote>
<h3>2.2 웹킷 동작 구조</h3>
<hr>
<p><img src="https://user-images.githubusercontent.com/72444675/157590845-6f165ab8-a7be-4e8a-b9e0-171f11e20766.png" alt="스크린샷_2021-07-26_오후_11 16 10"></p>
<p>출처: <a href="https://kim6394.tistory.com/217" target="_blank" rel="nofollow">https://kim6394.tistory.com/217</a></p>
<p>어태치먼트: 웹킷이 렌더 트리를 생성하기 위해 DOM 노드와 스타일 정보를 연결하는 과정이다.</p>
<h3>2.3 파싱(Parsing)</h3>
<hr>
<p>HTML에서 파싱이란 브라우저가 코드를 이해하고 사용할 수 있는 구조로 변환하는 것이다.</p>
<ul>
<li>
<p>Parser - Lexical analyze (파서-어휘분석기)
앞서 말했듯이 파싱은 어휘 분석과 구문 분석이라는 두 가지로 구분할 수 있다.</p>
<ul>
<li>어휘분석은 토큰분해, 즉 인간으로 정의하자면 사전에 등장하는 모든 단어이다.</li>
<li>구문분석은 언어의 구문 규칙을 적용하는 과정이다.
<br />
<br />
<img src="https://user-images.githubusercontent.com/72444675/157590875-e378c13c-b63b-46b0-8e84-0f071f991392.png" alt="스크린샷_2021-07-26_오후_11 22 58"></li>
</ul>
<br />
</li>
</ul>
<h3>파서는 두 가지 일을 한다.</h3>
<ul>
<li>자료를 유효한 토큰으로 분해하는 어휘 분석기</li>
<li>언어 구문 규칙에 따라 문서를 구조적으로 분석해 파싱 트리를 생성
파서는 보통 어휘 분석기로부터 새 토큰을 받아서 구문 규칙과 일치하는지 확인한다. 규칙에 맞으면 토큰에 해당하는 노드가 파싱트리에 추가되고, 파서는 또 다른 토큰을 요구한다.</li>
</ul>
<h3>2.4 DOM 파싱 예시</h3>
<hr>
<p>파싱 트리는 DOM 요소와 속성 노드의 트리로서 출력 트리가 된다.</p>
<p>DOM은 마크업과 1대1 관계를 맺는다.</p>
<deckgo-highlight-code language="jsx" terminal="carbon"  >
          <code slot="code">&lt;html&gt;
  &lt;body&gt;
    &lt;p&gt;Hello World&lt;/p&gt;
    &lt;div&gt;
      &lt;img src=&quot;#&quot; /&gt;
    &lt;/div&gt;
  &lt;/body&gt;
&lt;/html&gt;</code>
        </deckgo-highlight-code>
<p>예를 들어 위의 마크업의 경우 아래와 같은 트리로 변환될 수 있다.</p>
<p><img src="https://user-images.githubusercontent.com/72444675/157590923-a3752b08-80e6-4291-90c7-20ad38e73856.png" alt="스크린샷_2021-07-26_오후_11 26 55"></p>
<h1>3. XPath</h1>
<hr>
<h3>3.1 XPath 란?</h3>
<hr>
<p>XPath는 W3C의 표준으로 XML문서의 구조를 통해 경로위에 지정한 구문을 사용하여 항목을 배치하고 처리하는 방법을 기술하는 언어이다.</p>
<p>XPath는 XML 문서의 노드를 정의하기 위하여 경로식을 사용하며, 수학 함수와 기타 확장 가능한 표현들이 있다.</p>
<p>즉 html, xml상의 요소의 위치 값이다.</p>
<p>예를 들어 아래와 같은 DOM 트리가 있다고 할때, h1의 xpath는 html/body/h1이 된다.</p>
<p><img src="https://user-images.githubusercontent.com/72444675/157590969-a6cd7221-4a33-4558-a509-66db06eac513.png" alt="스크린샷_2021-07-26_오후_11 40 58"></p>
<h3>3.2 크롬 개발자 도구에서 XPath 가져오기</h3>
<hr>
<ol>
<li>f12키로 개발자 도구를 연다.</li>
<li>사이트에서 찾아보고 싶은 element를 선택한다.</li>
<li>우측 html문서에서 검색된 element에 대한 태그가 나타나면
<ul>
<li>우클릭 → copy → copy xpath 를 선택한다.</li>
</ul>
</li>
</ol>
<p><img src="https://user-images.githubusercontent.com/72444675/157591017-44cd19b1-6077-4ab4-8162-2998965007a0.png" alt="스크린샷_2021-07-26_오후_11 35 58"></p>
<p><img src="https://user-images.githubusercontent.com/72444675/157591038-1c599a47-54bf-43fb-b824-9ca4dce2c8df.png" alt="스크린샷_2021-07-26_오후_11 35 46"></p>
<ol>
<li>복사한 XPath를 붙여넣기 해보면 아래와 같다.
<ul>
<li>//는 중간 path를 생략하는 것을 나타낸다</li>
<li>@는 id와 class같이 요소를 결부하는 속성을 나타낸다.</li>
</ul>
</li>
</ol>
<deckgo-highlight-code language="jsx" terminal="carbon"  >
          <code slot="code">//*[@id=&quot;input&quot;]</code>
        </deckgo-highlight-code>
<p>‼️ 단 XPath는 요소의 위치를 기반으로 하는 값 이기 때문에 , UI가 변경되면 값이 변할 수 있다.</p></div><style data-emotion="css c5tzst">.css-c5tzst{display:grid;place-items:center;margin-top:auto;padding:50px 0;font-size:15px;text-align:center;line-height:1.5;}</style><div class="css-c5tzst evi8j960">Thank You for Visiting My Blog, Have a Good Day.<br/>@ 2022 Developer Jun, Powerd By Gatsby.</div></div></div><div id="gatsby-announcer" style="position:absolute;top:0;width:1px;height:1px;padding:0;overflow:hidden;clip:rect(0, 0, 0, 0);white-space:nowrap;border:0" aria-live="assertive" aria-atomic="true"></div></div><script id="gatsby-script-loader">/*<![CDATA[*/window.pagePath="/구문분석과DOMParser/";window.___webpackCompilationHash="8c045dea22caf3cb9e79";/*]]>*/</script><script id="gatsby-chunk-mapping">/*<![CDATA[*/window.___chunkMapping={"polyfill":["/polyfill-4718f0fec20e0d09d7f5.js"],"app":["/app-f34191c66d70ce0253b2.js"],"component---src-pages-404-tsx":["/component---src-pages-404-tsx-5a1562b048caf7768ff8.js"],"component---src-pages-blog-tsx":["/component---src-pages-blog-tsx-0495f90534ea9d80a60f.js"],"component---src-pages-index-tsx":["/component---src-pages-index-tsx-e5c9658481bba102ebab.js"],"component---src-templates-post-tsx":["/component---src-templates-post-tsx-cdd982b2742c5fa0a328.js"]};/*]]>*/</script><script src="/polyfill-4718f0fec20e0d09d7f5.js" nomodule=""></script><script src="/component---src-templates-post-tsx-cdd982b2742c5fa0a328.js" async=""></script><script src="/app-f34191c66d70ce0253b2.js" async=""></script><script src="/framework-6bdc9aaa9caa3de6408b.js" async=""></script><script src="/webpack-runtime-c0e03c5deb701c4aedb9.js" async=""></script></body></html>