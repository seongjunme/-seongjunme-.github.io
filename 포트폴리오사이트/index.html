<!DOCTYPE html><html><head><meta charSet="utf-8"/><meta http-equiv="x-ua-compatible" content="ie=edge"/><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"/><meta name="generator" content="Gatsby 4.8.0"/><title data-react-helmet="true"></title><style>.gatsby-image-wrapper{position:relative;overflow:hidden}.gatsby-image-wrapper picture.object-fit-polyfill{position:static!important}.gatsby-image-wrapper img{bottom:0;height:100%;left:0;margin:0;max-width:none;padding:0;position:absolute;right:0;top:0;width:100%;object-fit:cover}.gatsby-image-wrapper [data-main-image]{opacity:0;transform:translateZ(0);transition:opacity .25s linear;will-change:opacity}.gatsby-image-wrapper-constrained{display:inline-block;vertical-align:top}</style><noscript><style>.gatsby-image-wrapper noscript [data-main-image]{opacity:1!important}.gatsby-image-wrapper [data-placeholder-image]{opacity:0!important}</style></noscript><script type="module">const e="undefined"!=typeof HTMLImageElement&&"loading"in HTMLImageElement.prototype;e&&document.body.addEventListener("load",(function(e){if(void 0===e.target.dataset.mainImage)return;if(void 0===e.target.dataset.gatsbyImageSsr)return;const t=e.target;let a=null,n=t;for(;null===a&&n;)void 0!==n.parentNode.dataset.gatsbyImageWrapper&&(a=n.parentNode),n=n.parentNode;const o=a.querySelector("[data-placeholder-image]"),r=new Image;r.src=t.currentSrc,r.decode().catch((()=>{})).then((()=>{t.style.opacity=1,o&&(o.style.opacity=0,o.style.transition="opacity 500ms linear")}))}),!0);</script><link as="script" rel="preload" href="/webpack-runtime-c0e03c5deb701c4aedb9.js"/><link as="script" rel="preload" href="/framework-6bdc9aaa9caa3de6408b.js"/><link as="script" rel="preload" href="/app-f34191c66d70ce0253b2.js"/><link as="script" rel="preload" href="/component---src-templates-post-tsx-cdd982b2742c5fa0a328.js"/><link as="fetch" rel="preload" href="/page-data/포트폴리오사이트/page-data.json" crossorigin="anonymous"/><link as="fetch" rel="preload" href="/page-data/app-data.json" crossorigin="anonymous"/></head><body><div id="___gatsby"><div style="outline:none" tabindex="-1" id="gatsby-focus-wrapper"><style data-emotion="css rmgwh1">.css-rmgwh1{display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-flex-direction:column;-ms-flex-direction:column;flex-direction:column;height:100%;background-color:#121212;color:white;}.css-rmgwh1::-webkit-scrollbar-thumb{background-color:#ffffff;}</style><div class="css-rmgwh1 ef79xez0"><style data-emotion="css-global 1llifsc">@import url(http://fonts.googleapis.com/css?family=Open+Sans:300italic,300);*{padding:0;margin:0;box-sizing:border-box;font-family:'Open Sans',Helvetica,sans-serif;font-weight:300;}html,body,#___gatsby{height:100%;}a,a:hover{color:inherit;-webkit-text-decoration:none;text-decoration:none;cursor:pointer;}</style><style data-emotion="css z5i94e">.css-z5i94e{position:relative;width:100%;height:350px;}</style><div class="css-z5i94e evp6fv50"><style data-emotion="css 1cf6hsn">.css-1cf6hsn{display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-flex-direction:column;-ms-flex-direction:column;flex-direction:column;width:768px;height:100%;margin:0 auto;padding:60px 0;color:#ffffff;}</style><div class="css-1cf6hsn e1x0sffc2"><style data-emotion="css 1pr6csa">.css-1pr6csa{overflow:hidden;overflow-wrap:break-word;margin-top:auto;text-overflow:ellipsis;white-space:normal;font-size:45px;font-weight:800;}</style><div class="css-1pr6csa e1x0sffc1">Gatsby로 만든 포트폴리오 사이트</div><style data-emotion="css 15xrm5i">.css-15xrm5i{display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-flex-direction:column;-ms-flex-direction:column;flex-direction:column;-webkit-box-pack:start;-ms-flex-pack:start;-webkit-justify-content:flex-start;justify-content:flex-start;-webkit-box-pack:justify;-webkit-justify-content:space-between;justify-content:space-between;font-size:18px;font-weight:700;}.css-15xrm5i div{margin-top:10px;}</style><div class="css-15xrm5i e1x0sffc0"><div>2022.03.08.</div><div>React / Gatsby</div></div></div></div><style data-emotion="css n1la39">.css-n1la39{display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-flex-direction:column;-ms-flex-direction:column;flex-direction:column;width:768px;margin:0 auto;word-break:break-all;line-height:1.8;font-size:1.125rem;font-weight:400;color:#ececec;}.css-n1la39 p{padding:3px 0;}.css-n1la39 h1,.css-n1la39 h2,.css-n1la39 h3,.css-n1la39 h4{margin:2.414rem 0 1rem;font-weight:inherit;line-height:1.42;}.css-n1la39 h1{font-size:3.598rem;}.css-n1la39 h2{font-size:2.827rem;}.css-n1la39 h3{font-size:1.999rem;}.css-n1la39 h4{font-size:1.414rem;}.css-n1la39 h5{font-size:1.121rem;}.css-n1la39 h6{font-size:0.88rem;}.css-n1la39 blockquote{margin:10px 0;border-left:5px solid #7a7a7a;font-style:italic;padding:5px 15px;text-align:left;background-color:#1e1e1e;}.css-n1la39 aside{background-color:#1e1e1e;margin:10px 0;}.css-n1la39 table{background-color:#22272e;border-collapse:collapse;}.css-n1la39 table th,.css-n1la39 table td{padding:6px 13px;}.css-n1la39 table th:not(first-child),.css-n1la39 table td:not(first-child){border:1px solid #444c56;}.css-n1la39 ol,.css-n1la39 ul{margin-left:20px;padding:10px 0;}.css-n1la39 hr{margin:30px 0;background:#4d4d4d;border:none;height:1px;width:100%;}.css-n1la39 a:link{-webkit-text-decoration:none;text-decoration:none;text-shadow:0 0 24px;}.css-n1la39 a:hover{color:#4263eb;}.css-n1la39 strong{font-weight:bold;}.css-n1la39 deckgo-highlight-code{font-size:14px;}</style><div class="css-n1la39 era8a5j0"><h3><a href="https://github.com/seongjunme/my-blog" target="_blank" rel="nofollow">프로젝트 repository 바로가기</a></h3>
<hr>
<h2>🖥 프로젝트 소개</h2>
<p>평소에 구현해보고 싶었던 Full Page의 기능을 중점으로</p>
<p>포트폴리오와 작성한 블로그들을 정리하기 위한 사이트</p>
<h2>📚 기술 스택</h2>
<ul>
<li>
<p>React (hooks)</p>
</li>
<li>
<p>TypeScript</p>
</li>
<li>
<p>Emotion</p>
</li>
<li>
<p>Gatsby</p>
</li>
<li>
<p>Graphql</p>
</li>
</ul>
<h2>🛠 주요 기능</h2>
<ul>
<li>Gatsby를 이용한 블로그</li>
<li>Full Page 사이트</li>
<li>무한 스크롤 기능</li>
</ul>
<h2>👍 기술 특장점</h2>
<h3>1️⃣ Graphql을 이용한 Markdown 데이터 요청</h3>
<p>Gatsby에서 제공해주는 Graphql을 이용하여 Markdown 데이터 소스를 얻고, 이를 html로 변환할 수 있다.
이를 위해서는 먼저 두 가지 플러그인이 필요하다.</p>
<ul>
<li>gatsby-source-filesystem</li>
<li>gatsby-transformer-remark</li>
</ul>
<p>플러그인을 설치한 후 gatsby-config에 다음과 같이 작성해준다.</p>
<deckgo-highlight-code language="js" terminal="carbon"  >
          <code slot="code">// gatsby-config.js
module.exports = {
  plugins: [
    {
      resolve: `gatsby-source-filesystem`,
      options: {
        name: `contents`,
        path: `${__dirname}/contents`,
      },
    },
    {
      resolve: `gatsby-transformer-remark`,
      options: {
        plugins: [...],
      },
    }
  ],
};
</code>
        </deckgo-highlight-code>
<h4><strong>gatsby-source-filesystem</strong></h4>
<p>로컬 파일 시스템의 파일을 File 노드로 생성하여 graphql을 통해 데이터를 얻을 수 있다. <br />
단, 마크다운을 path에 지정한 경로에 저장해야한다.</p>
<h4>gatsby-transformer-remark</h4>
<p>마크다운 파일을 파싱하여 MarkdownRemark 노드로 생성한다.
생성된 노드는 graphql을 통해 데이터를 얻을 수 있다.</p>
<br />
<deckgo-highlight-code  terminal="carbon"  >
          <code slot="code">query getMarkdownData {
  allMarkdownRemark {
    edges {
      node {
        html
        id
        frontmatter {
          title,
          summary,
          ...
        }
      }
    }
  }
}</code>
        </deckgo-highlight-code>
<br />
<h3>2️⃣ Gatsby의 slug 기능을 이용하여 해당 Markdown 게시글과 연동</h3>
<h4>slug 생성</h4>
<p>마크다운 데이터에 slug 필드를 추가하여 해당 게시물에 접근하기 위한 url을 생성한다.</p>
<p>해당 기능을 사용하기 위해선 onCreateNode라는 gatsby에서 제공하는 API를 사용한다.</p>
<br />
<deckgo-highlight-code language="js" terminal="carbon"  >
          <code slot="code">// gatsby-node.js
exports.onCreateNode = ({ node, getNode, actions }) =&gt; {
  const { createNodeField } = actions;

  if (node.internal.type === `MarkdownRemark`) {
    const slug = createFilePath({ node, getNode });

    createNodeField({ node, name: &#39;slug&#39;, value: slug });
  }
};</code>
        </deckgo-highlight-code>
<br />
마크다운 데이터에 한해서 slug 필드를 추가한다.
그리고 slug데이터는 경로와 파일명을 조합해 생성된다.
<p>ex) contents/ShallWeSound.md -> domain/ShallWeSound</p>
<h4>slug를 이용해 페이지 생성</h4>
<p>마크다운 데이터를 이용해 slug를 생성해주었으니, 이제는 이 slug를 이용해 접근할 페이지를 생성한다.
페이지 생성은 gatsby의 createPages API를 이용한다.</p>
<br />
<deckgo-highlight-code language="js" terminal="carbon"  >
          <code slot="code">// gatsby-node.js
exports.createPages = async ({ actions, graphql, reporter }) =&gt; {
  const { createPage } = actions;

  const queryAllMarkdownData = await graphql(
    `
      {
        allMarkdownRemark {
          edges {
            node {
              fields {
                slug
              }
            }
          }
        }
      }
    `,
  );

  if (queryAllMarkdownData.errors) {
    reporter.panicOnBuild(`Query Error`);
    return;
  }

  const PostTemplateComponent = path.resolve(__dirname, &#39;src/templates/post.tsx&#39;);

  const generatePostPage = ({
    node: {
      fields: { slug },
    },
  }) =&gt; {
    const pageOptions = {
      path: slug,
      component: PostTemplateComponent,
      context: { slug },
    };

    createPage(pageOptions);
  };

  queryAllMarkdownData.data.allMarkdownRemark.edges.forEach(generatePostPage);
};</code>
        </deckgo-highlight-code>
<br />
<p>template 폴더에 post.tsx로 게시글 페이지의 템플릿을 정의한다.
그리고 그 템플릿 컴포넌트를 불러온다.</p>
<p>다음으로 pageOtions을 정의하고, 실제로 페이지를 생성해줄 generatePostPage 함수를 정의한다.
여기서 path는 페이지의 경로를 나타내고, component는 게시글을 렌더링할 컴포넌트를 의미한다.
마지막으로 context는 바로 앞서 정의한 component에 props로 넘겨줄 수 있는 값이다.
이 slug를 통해 해당 컴포넌트에서 맞는 마크다운 문서를 찾아 불러올 수 있다.</p>
<p>그리고 graphql을 통해 불러온 queryAllMarkdownData 값에서 markdown 데이터가 들어있는 edges를 반복하여 페이지 생성 함수를 실행해 준다.</p>
<h3>3️⃣ Full Page 구현</h3>
<h4>useFullPage라는 커스텀 훅을 생성 - index.tsx</h4>
<ul>
<li>반환 값으로는
<ul>
<li>최상단을 지정하기 위한 outerRef</li>
<li>현재 부분(페이지)를 저장하기 위한 currentPageName</li>
<li>full page 상단의 navBar를 클릭했을 때의 이벤트 핸들러 onClickNavBar</li>
</ul>
</li>
</ul>
<deckgo-highlight-code language="jsx" terminal="carbon"  >
          <code slot="code">// index.tsx
const Index: React.FC = () =&gt; {
  const [outerRef, currentPageName, onClickNavBar] = useFullPage({ maxPageCount: 3 });

  return (
    &lt;Background ref={outerRef} className=&quot;outer&quot;&gt;
      &lt;NavBar currentPageName={currentPageName} onClickNavBar={onClickNavBar} /&gt;
      &lt;About /&gt;
      &lt;PostList /&gt;
      &lt;PostList /&gt;
      &lt;Contact /&gt;
    &lt;/Background&gt;
  );
};</code>
        </deckgo-highlight-code>
<h4>useFullPage.tsx</h4>
<ul>
<li>인자로 페이지(파트)의 최대 수를 받는다.
<ul>
<li>페이지 수는 0부터 시작</li>
</ul>
</li>
<li>현재 페이지 번호를 useRef로 관리한다.
<ul>
<li>번호를 state로 관리하면 스크롤을 이동할 때, state의 최신값을 사용하기가 어려워진다.</li>
</ul>
</li>
</ul>
<deckgo-highlight-code language="js" terminal="carbon"  >
          <code slot="code">// useFullPage.tsx
const PAGE_NAMES = [&#39;About&#39;, &#39;Project&#39;, &#39;Blog&#39;, &#39;Contact&#39;];

const useFullPage = ({ maxPageCount }: { maxPageCount: number }) =&gt; {
  const outerRef = useRef&lt;any&gt;();
  const currentPage = useRef(0);
  const [currentPageName, setCurrentPageName] = useState(PAGE_NAMES[currentPage.current]);

  ...
}</code>
        </deckgo-highlight-code>
<h4>wheel 동작에 따라 currentPage가 가리키는 부분으로 스크롤을 이동시킨다.</h4>
<ul>
<li>이동 시키는 기준은 현재 화면 크기(window.innerHeight)와 currentPage가 가리키는 값이다.</li>
<li>현재 화면 크기가 720px이고 현재 페이지 번호가 0일 때 top은 0이되고, 페이지 번호가 1이면 top은 720px이 된다.</li>
<li>즉, 0~720px은 페이지 0이 차지하고, 720px ~ 1440px 은 페이지 1이 차지한다는 뜻이다.</li>
</ul>
<deckgo-highlight-code language="jsx" terminal="carbon"  >
          <code slot="code">// useFullPage.tsx
const useFullPage = ({ maxPageCount }: { maxPageCount: number }) =&gt; {
  ...

  const scrollToCurrentPage = () =&gt; {
    outerRef.current.scrollTo({
      top: window.innerHeight * currentPage.current,
      left: 0,
      behavior: &#39;smooth&#39;,
    });
  };

  const scrollDown = () =&gt; {
    currentPage.current += 1;
    scrollToCurrentPage();
    setCurrentPageName(PAGE_NAMES[currentPage.current]);
  };

  const scrollUp = () =&gt; {
    currentPage.current -= 1;
    scrollToCurrentPage();
    setCurrentPageName(PAGE_NAMES[currentPage.current]);
  };
}</code>
        </deckgo-highlight-code>
<h4>outerRef에 이벤트 등록</h4>
<ul>
<li>deltaY 값을 확인해, wheel 이벤트가 위인지, 아래인지 구분하여 동작시킨다.</li>
<li>debounce를 적용하여 한번에 wheel 이벤트 핸들러가 연속으로 수행되지 않도록 한다.
<ul>
<li>마우스 휠의 경우 굉장히 민감하기 때문에 조금만 움직여도 수십개의 이벤트가 발생한다.</li>
<li>따라서 스크롤 한번으로 첫 페이지에서 마지막 페이지 까지 내려가는 현상이 발생했고, 이를 debounce를 적용함으로써 해결하였다.</li>
</ul>
</li>
</ul>
<deckgo-highlight-code language="jsx" terminal="carbon"  >
          <code slot="code">// useFullPage.tsx
const useFullPage = ({ maxPageCount }: { maxPageCount: number }) =&gt; {
  ...

  useEffect(() =&gt; {
    const wheelHandler = debounce((e: WheelEvent) =&gt; {
      e.preventDefault();

      const { deltaY } = e;

      if (deltaY &gt; 0 &amp;&amp; currentPage.current &lt; maxPageCount) {
        scrollDown();
      } else if (deltaY &lt; 0 &amp;&amp; currentPage.current &gt; 0) {
        scrollUp();
      }
    }, 50);

    outerRef.current?.addEventListener(&#39;wheel&#39;, wheelHandler);

    return () =&gt; {
      outerRef.current?.removeEventListener(&#39;wheel&#39;, wheelHandler);
    };
  }, []);
}
</code>
        </deckgo-highlight-code>
<br />
<deckgo-highlight-code language="js" terminal="carbon"  >
          <code slot="code">// debounce.ts
const debounce = (callback: (...arg: any) =&gt; void, delay: number) =&gt; {
  let timer: NodeJS.Timeout;

  return (...arg: any) =&gt; {
    clearTimeout(timer);
    timer = setTimeout(() =&gt; callback(...arg), delay);
  };
};

export default debounce;</code>
        </deckgo-highlight-code>
<h4>마지막으로 브라우저 창의 크기를 변경할 시, window.innerHeight를 다시 계산하여 해당 값에 맞게 스크롤을 이동시켜야 한다.</h4>
<ul>
<li>resize 이벤트 발생 시, 현재 페이지를 기준으로 스크롤을 이동시켜주는 함수를 실행시킨다.</li>
</ul>
<deckgo-highlight-code language="js" terminal="carbon"  >
          <code slot="code">// useFullPage.tsx
useEffect(() =&gt; {
  window.addEventListener(&#39;resize&#39;, scrollToCurrentPage);

  return () =&gt; {
    window.removeEventListener(&#39;resize&#39;, scrollToCurrentPage);
  };
});</code>
        </deckgo-highlight-code>
<br />
<h3>4️⃣ 무한 스크롤 구현</h3>
<h4>useInfiniteScroll 라는 커스텀 훅을 생성하고 사용</h4>
<ul>
<li>posts 배열과, 카테고리에 따른 필터링을 위해 selectedCategory를 인자로 넘겨준다.</li>
<li>반환 값으로는 observe할 Ref와 posts의 부분 배열인 postsByPage 배열이 반환된다.</li>
</ul>
<deckgo-highlight-code language="jsx" terminal="carbon"  >
          <code slot="code">const BlogList: React.FC&lt;Props&gt; = ({ posts, selectedCategory }) =&gt; {
  const { targetRef, postsByPage } = useInfiniteScroll({ posts, selectedCategory });

  return (
    &lt;Wrapper ref={targetRef}&gt;
      {postsByPage.map(
        ({
          node: {
            id,
            fields: { slug },
            frontmatter,
          },
        }) =&gt; (
          &lt;PostItem key={id} link={slug} {...frontmatter} /&gt;
        ),
      )}
    &lt;/Wrapper&gt;
  );
};</code>
        </deckgo-highlight-code>
<br />
<h4>useInfiniteScroll 구현</h4>
<ul>
<li>page 상태에 따라 렌더링할 post의 개수를 정한다.
<ul>
<li>page 값이 1이면 page(1) * POST_COUNT_BY_PAGE(9) = 9 개의 post가 반환된다.</li>
</ul>
</li>
<li>IntersectionOberserver를 활용하여 observe 이벤트 발생 시 page를 1증가 시킨다.
<ul>
<li>page가 증가함에 따라 최대 9개의 새로운 포스트가 추가로 반환된다.</li>
</ul>
</li>
<li>observer가 targetRef의 children의 마지막 요소를 관찰하도록 한다.
<ul>
<li>스크롤을 끝까지 내려서 마지막 요소가 관찰되면 등록한 이벤트 리스너를 수행한다.</li>
</ul>
</li>
<li>observer를 매번 disconnect하고 새롭게 observe등록을 하는 이유는 마지막 post까지 렌더링했다면 더 이상 observe할 필요가 없기 때문에 매번 모든 post가 출력됐다면 observe를 등록하지 않도록 하기 위함이다.</li>
<li>마지막으로 selectedCategory가 변경되면 page를 1로 초기화 해주는 작업을 한다.
<ul>
<li>초기화 하지 않으면 카테고리가 바뀌어도 page가 그대로 유지 되는 현상이 발생한다.</li>
</ul>
</li>
</ul>
<deckgo-highlight-code language="jsx" terminal="carbon"  >
          <code slot="code">// useInfiniteScroll.tsx
import { MutableRefObject, useState, useRef, useEffect, useMemo } from &#39;react&#39;;
import { PostListType } from &#39;types/post.types&#39;;

const POST_COUNT_BY_PAGE = 9;

const useInfiniteScroll = ({ posts, selectedCategory }: { posts: PostListType[], selectedCategory: string }) =&gt; {
  const [page, setPage] = useState(1);
  const targetRef: MutableRefObject&lt;HTMLDivElement | null&gt; = useRef &lt; HTMLDivElement &gt; null;

  const filteredPosts = useMemo(
    () =&gt;
      posts.filter(
        ({
          node: {
            frontmatter: { categories },
          },
        }) =&gt; selectedCategory === &#39;All&#39; || categories.includes(selectedCategory),
      ),
    [selectedCategory],
  );

  const observer = new IntersectionObserver(
    (entries, observer) =&gt; {
      if (!entries[0].isIntersecting) return;

      setPage(prev =&gt; prev + 1);
      observer.disconnect();
    },
    {
      threshold: 1.0,
    },
  );

  useEffect(() =&gt; setPage(1), [selectedCategory]);

  useEffect(() =&gt; {
    if (
      !targetRef.current ||
      page * POST_COUNT_BY_PAGE &gt;= filteredPosts.length ||
      targetRef.current.children.length &lt;= 0
    )
      return;

    observer.observe(targetRef.current.children[targetRef.current.children.length - 1]);
  }, [page, selectedCategory]);

  return {
    targetRef,
    postsByPage: filteredPosts.slice(0, page * POST_COUNT_BY_PAGE),
  };
};

export default useInfiniteScroll;</code>
        </deckgo-highlight-code></div><style data-emotion="css c5tzst">.css-c5tzst{display:grid;place-items:center;margin-top:auto;padding:50px 0;font-size:15px;text-align:center;line-height:1.5;}</style><div class="css-c5tzst evi8j960">Thank You for Visiting My Blog, Have a Good Day.<br/>@ 2022 Developer Jun, Powerd By Gatsby.</div></div></div><div id="gatsby-announcer" style="position:absolute;top:0;width:1px;height:1px;padding:0;overflow:hidden;clip:rect(0, 0, 0, 0);white-space:nowrap;border:0" aria-live="assertive" aria-atomic="true"></div></div><script id="gatsby-script-loader">/*<![CDATA[*/window.pagePath="/포트폴리오사이트/";window.___webpackCompilationHash="8c045dea22caf3cb9e79";/*]]>*/</script><script id="gatsby-chunk-mapping">/*<![CDATA[*/window.___chunkMapping={"polyfill":["/polyfill-4718f0fec20e0d09d7f5.js"],"app":["/app-f34191c66d70ce0253b2.js"],"component---src-pages-404-tsx":["/component---src-pages-404-tsx-5a1562b048caf7768ff8.js"],"component---src-pages-blog-tsx":["/component---src-pages-blog-tsx-0495f90534ea9d80a60f.js"],"component---src-pages-index-tsx":["/component---src-pages-index-tsx-e5c9658481bba102ebab.js"],"component---src-templates-post-tsx":["/component---src-templates-post-tsx-cdd982b2742c5fa0a328.js"]};/*]]>*/</script><script src="/polyfill-4718f0fec20e0d09d7f5.js" nomodule=""></script><script src="/component---src-templates-post-tsx-cdd982b2742c5fa0a328.js" async=""></script><script src="/app-f34191c66d70ce0253b2.js" async=""></script><script src="/framework-6bdc9aaa9caa3de6408b.js" async=""></script><script src="/webpack-runtime-c0e03c5deb701c4aedb9.js" async=""></script></body></html>