<!DOCTYPE html><html><head><meta charSet="utf-8"/><meta http-equiv="x-ua-compatible" content="ie=edge"/><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"/><meta name="generator" content="Gatsby 4.8.0"/><title data-react-helmet="true"></title><style>.gatsby-image-wrapper{position:relative;overflow:hidden}.gatsby-image-wrapper picture.object-fit-polyfill{position:static!important}.gatsby-image-wrapper img{bottom:0;height:100%;left:0;margin:0;max-width:none;padding:0;position:absolute;right:0;top:0;width:100%;object-fit:cover}.gatsby-image-wrapper [data-main-image]{opacity:0;transform:translateZ(0);transition:opacity .25s linear;will-change:opacity}.gatsby-image-wrapper-constrained{display:inline-block;vertical-align:top}</style><noscript><style>.gatsby-image-wrapper noscript [data-main-image]{opacity:1!important}.gatsby-image-wrapper [data-placeholder-image]{opacity:0!important}</style></noscript><script type="module">const e="undefined"!=typeof HTMLImageElement&&"loading"in HTMLImageElement.prototype;e&&document.body.addEventListener("load",(function(e){if(void 0===e.target.dataset.mainImage)return;if(void 0===e.target.dataset.gatsbyImageSsr)return;const t=e.target;let a=null,n=t;for(;null===a&&n;)void 0!==n.parentNode.dataset.gatsbyImageWrapper&&(a=n.parentNode),n=n.parentNode;const o=a.querySelector("[data-placeholder-image]"),r=new Image;r.src=t.currentSrc,r.decode().catch((()=>{})).then((()=>{t.style.opacity=1,o&&(o.style.opacity=0,o.style.transition="opacity 500ms linear")}))}),!0);</script><link as="script" rel="preload" href="/webpack-runtime-86f5ed40190be432559e.js"/><link as="script" rel="preload" href="/framework-6bdc9aaa9caa3de6408b.js"/><link as="script" rel="preload" href="/app-f34191c66d70ce0253b2.js"/><link as="script" rel="preload" href="/component---src-templates-post-tsx-268e05f5ac4790150225.js"/><link as="fetch" rel="preload" href="/page-data/[js]_this/page-data.json" crossorigin="anonymous"/><link as="fetch" rel="preload" href="/page-data/app-data.json" crossorigin="anonymous"/></head><body><div id="___gatsby"><div style="outline:none" tabindex="-1" id="gatsby-focus-wrapper"><style data-emotion="css 8ugl6e">.css-8ugl6e{display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-flex-direction:column;-ms-flex-direction:column;flex-direction:column;min-height:100vh;background-color:#121212;color:white;}.css-8ugl6e::-webkit-scrollbar-thumb{background-color:#ffffff;}</style><div class="css-8ugl6e ef79xez0"><style data-emotion="css-global 1llifsc">@import url(http://fonts.googleapis.com/css?family=Open+Sans:300italic,300);*{padding:0;margin:0;box-sizing:border-box;font-family:'Open Sans',Helvetica,sans-serif;font-weight:300;}html,body,#___gatsby{height:100%;}a,a:hover{color:inherit;-webkit-text-decoration:none;text-decoration:none;cursor:pointer;}</style><style data-emotion="css z5i94e">.css-z5i94e{position:relative;width:100%;height:350px;}</style><div class="css-z5i94e evp6fv50"><style data-emotion="css 1cf6hsn">.css-1cf6hsn{display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-flex-direction:column;-ms-flex-direction:column;flex-direction:column;width:768px;height:100%;margin:0 auto;padding:60px 0;color:#ffffff;}</style><div class="css-1cf6hsn e1x0sffc2"><style data-emotion="css 1pr6csa">.css-1pr6csa{overflow:hidden;overflow-wrap:break-word;margin-top:auto;text-overflow:ellipsis;white-space:normal;font-size:45px;font-weight:800;}</style><div class="css-1pr6csa e1x0sffc1">[JS] this</div><style data-emotion="css 15xrm5i">.css-15xrm5i{display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-flex-direction:column;-ms-flex-direction:column;flex-direction:column;-webkit-box-pack:start;-ms-flex-pack:start;-webkit-justify-content:flex-start;justify-content:flex-start;-webkit-box-pack:justify;-webkit-justify-content:space-between;justify-content:space-between;font-size:18px;font-weight:700;}.css-15xrm5i div{margin-top:10px;}</style><div class="css-15xrm5i e1x0sffc0"><div>2021.10.28.</div><div>JavaScript</div></div></div></div><style data-emotion="css n1la39">.css-n1la39{display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-flex-direction:column;-ms-flex-direction:column;flex-direction:column;width:768px;margin:0 auto;word-break:break-all;line-height:1.8;font-size:1.125rem;font-weight:400;color:#ececec;}.css-n1la39 p{padding:3px 0;}.css-n1la39 h1,.css-n1la39 h2,.css-n1la39 h3,.css-n1la39 h4{margin:2.414rem 0 1rem;font-weight:inherit;line-height:1.42;}.css-n1la39 h1{font-size:3.598rem;}.css-n1la39 h2{font-size:2.827rem;}.css-n1la39 h3{font-size:1.999rem;}.css-n1la39 h4{font-size:1.414rem;}.css-n1la39 h5{font-size:1.121rem;}.css-n1la39 h6{font-size:0.88rem;}.css-n1la39 blockquote{margin:10px 0;border-left:5px solid #7a7a7a;font-style:italic;padding:5px 15px;text-align:left;background-color:#1e1e1e;}.css-n1la39 aside{background-color:#1e1e1e;margin:10px 0;}.css-n1la39 table{background-color:#22272e;border-collapse:collapse;}.css-n1la39 table th,.css-n1la39 table td{padding:6px 13px;}.css-n1la39 table th:not(first-child),.css-n1la39 table td:not(first-child){border:1px solid #444c56;}.css-n1la39 ol,.css-n1la39 ul{margin-left:20px;padding:10px 0;}.css-n1la39 hr{margin:30px 0;background:#4d4d4d;border:none;height:1px;width:100%;}.css-n1la39 a:link{-webkit-text-decoration:none;text-decoration:none;text-shadow:0 0 24px;}.css-n1la39 a:hover{color:#4263eb;}.css-n1la39 strong{font-weight:bold;}.css-n1la39 deckgo-highlight-code{font-size:14px;}</style><div class="css-n1la39 era8a5j0"><h1>this 키워드가 필요한 이유</h1>
<p>JS에서 객체는 상태를 나타내는 프로퍼티와 동작을 나타내는 메서드를 하나의 논리적인 단위로 묶은 복합적 자료구조다.</p>
<p>동작을 나타내는 메서드는 자신이 속한 객체의 상태, 즉 프로퍼티를 참조하고 변경할 수 있어야 한다.
이때 메서드가 자신이 속한 객체의 프로퍼티를 참조하려면 먼저 자신이 속한 객체를 가리키는 식별자를 참조할 수 있어야 한다.</p>
<br />
<deckgo-highlight-code  terminal="carbon"  >
          <code slot="code">const circle = {
	radius: 5,
    getDiameter() {
    	return 2*circle.radius
    }
}</code>
        </deckgo-highlight-code>
<br />
getDiameter 메서드 내에서 메서드 자신이 속한 객체를 가리키는 식별자 circle를 참조하고 있다.
getDiameter 메서드가 호출되는 시점은 이미 circle 객체가 생성되어 식별자에 할당되었기 때문에 참조가 가능하다.
<p>하지만 자기 자신이 속한 객체를 재귀적으로 참조하는 방식은 일반적이지 않으며 바람직하지도 않다.</p>
<p>또, 생성자 함수 방식으로 인스턴스를 생성하는 경우를 생각해보자.</p>
<br />
<deckgo-highlight-code  terminal="carbon"  >
          <code slot="code">function Circle(radius) {
	???.radius = radius
}</code>
        </deckgo-highlight-code>
<br />
<p>생성자 함수 내부에서는 프로퍼티 또는 메서드를 추가하기 위해 자신이 생성할 인스턴스를 참조할 수 있어야 한다. 하지만 생성자 함수에 의한 객체 생성 방식은 먼저 생성자 함수를 정의한 이후 new 연산자와 함께 생성자 함수를 호출하는 단계가 추가로 필요하다. 다시 말해, 생성자 함수로 인스턴스를 생성하려면 먼저 생성자 함수가 존재해야 한다. <br /></p>
<p>생성자 함수를 정의하는 시점에는 아직 인스턴스를 생성하기 이전이므로 생성자 함수가 생성할 인스턴스를 가리키는 식별자를 알 수 없다. 따라서 자신이 속한 객체 또는 자신이 생성할 인스턴스를 가리키는 특수한 식별자가 필요하다. 이를 위해 JS에선 this 키워드를 제공한다. <br /></p>
<p><strong>즉, this는 자신이 속한 객체 또는 자신이 생성할 인스턴스를 가리키는 자기 참조 변수다.</strong></p>
<p>this는 자바스크립트 엔진에 의해 암묵적으로 생성되며, 코드 어디서든 참조할 수 있다.
함수를 호출하면 arguments 객체와 this가 암묵적으로 함수 내부에 전달된다.
arguments를 지역 변수처럼 사용할 수 있는 것 처럼 this도 지역 변수처럼 사용할 수 있다.</p>
<p><strong>단, this가 가리키는 값, 즉 this 바인딩은 함수 호출 방식에 의해 동적으로 결정된다.</strong></p>
<blockquote>
<p>바인딩이란 식별자와 값을 연결하는 과정을 의미한다. 예를 들어 변수 선언은 변수 이름(식별자)과 확보된 메모리 공간의 주소를 바인딩하는 것이다.</p>
</blockquote>
<p>이제 위의 예시 코드를 this를 이용하여 다시 작성해보자.</p>
<br />
<deckgo-highlight-code  terminal="carbon"  >
          <code slot="code">const circle = {
	radius: 5,
    getDiameter() {
    	return 2*this.radius
    }
}</code>
        </deckgo-highlight-code>
<br />
<p><strong>객체 리터럴의 메서드 내부에서의 this는 메서드를 호출한 객체, 즉 circle를 가리킨다.</strong></p>
<br />
<deckgo-highlight-code  terminal="carbon"  >
          <code slot="code">function Circle(radius) {
	this.radius = radius
}</code>
        </deckgo-highlight-code>
<br />
<p><strong>생성자 함수 내부의 this는 생성자 함수가 생성할 인스턴스를 가리킨다.</strong></p>
<h1>함수 호출 방식과 this 바인딩</h1>
<h2>일반 함수 호출</h2>
<p>일반 함수 호출은 기본적으로 this에 전역 객체(window)가 바인딩 된다.
<br /></p>
<deckgo-highlight-code  terminal="carbon"  >
          <code slot="code">function foo() {
	console.log(this) // window

    function bar() {
    	console.log(this) //window
    }
}</code>
        </deckgo-highlight-code>
<br />
<p>콜백 함수로 일반 함수가 호출된다면 마찬가지로 window를 가리킨다.
<br /></p>
<deckgo-highlight-code  terminal="carbon"  >
          <code slot="code">const value = 1

const obj = {
	value: 100,
    foo() {
    	setTimeout(function() {
        	console.log(this.value) // 1
        }, 1000)
    }
}</code>
        </deckgo-highlight-code>
<br />
<p>하지만 화살표 함수를 사용한다면 함수 내부의 this는 상위 스코프의 this를 가리킨다.
<br /></p>
<deckgo-highlight-code  terminal="carbon"  >
          <code slot="code">const value = 1

const obj = {
	value: 100,
    foo() {
    	setTimeout(() =&gt; {
        	console.log(this.value) // 100
        }, 1000)
    }
}</code>
        </deckgo-highlight-code>
<br />
<h2>메서드 호출</h2>
<p>메서드 내부의 this에는 메서드를 호출한 객체, 즉 메서드를 호출할 때 메서드 이름 앞의 마침표(.) 연산자 앞에 기술한 객체가 바인딩된다.</p>
<p>주의 해야할 것은 this는 메서드를 소유한 객체가 아닌 메서드를 호출한 객체에 바인딩 된다는 것이다.</p>
<br />
<deckgo-highlight-code  terminal="carbon"  >
          <code slot="code">const person = {
	name: &#39;Lee&#39;,
    getName() {
    	return this.name
    }
}

const anotherPerson = {
	name: &#39;Kim&#39;,
}

anotherPerson.getName = person.getName

console.log(anotherPerson.getName()) // Kim

const getName = person.getName

console.log(getName()) // &#39;&#39;
</code>
        </deckgo-highlight-code>
<br />
anotherPerson에 person의 getName 메서드를 할당했지만 this는 호출한 객체가 바인딩 되므로 Kim이 출력된다.
<p>그리고 getName에도 person의 getName 메서드를 할당했지만 this는 전역 객체인 window의 name에 접근하게 된다.</p>
<blockquote>
<p>브라우저 환경에서 window.name은 브라우저 창의 이름을 나타내는 빌트인 프로퍼티이며 기본값은 ”이다.</p>
</blockquote>
<h2>생성자 함수 호출</h2>
<p>생성자 함수 내부의 this는 생성자 함수가 (미래에) 생성할 인스턴스가 바인딩 된다.
<br /></p>
<deckgo-highlight-code  terminal="carbon"  >
          <code slot="code">function Circle(radius) {
	this.radius = radius,
    getDiameter() {
    	return 2*this.radius
    }
}

const circle1 = new Circle(5)
const circle2 = new Circle(10)

console.log(circle1.getDiameter()) // 10
console.log(circle2.getDiameter()) // 20</code>
        </deckgo-highlight-code>
<br />
<h2>Function.prototype.apply/call/bind 메서드에 의한 간접 호출</h2>
<h3>apply와 call</h3>
<p>apply와 call 메서드의 본질적인 기능은 함수를 호출하는 것이다.
함수를 호출하면서 첫 번째 인자로 전달한 특정 객체를 호출한 함수의 this에 바인딩한다.
<br /></p>
<deckgo-highlight-code  terminal="carbon"  >
          <code slot="code">function getThisBinding() {
	console.log(arguments)
	return this
}

const thisArg = { a: 1}

console.log(getThisBinding.apply(thisArg, [1, 2, 3]))
// Arguments(3) [1, 2, 3, callee: f, Symbol.iterator): f]
// {a: 1}
console.log(getThisBinding.call(thisArg, 1, 2, 3)) // {a: 1}
// Arguments(3) [1, 2, 3, callee: f, Symbol.iterator): f]
// {a: 1}</code>
        </deckgo-highlight-code>
<br />
apply와 call 메서드는 호출할 함수에 인자를 전달하는 방식만 다를 뿐 동일하게 동작한다.
<h3>bind</h3>
<p>bind 메서드는 apply, call과 달리 함수를 바로 호출하지 않고 this로 사용할 객체만 전달한다.
<br /></p>
<deckgo-highlight-code  terminal="carbon"  >
          <code slot="code">function getThisBinding() {
	console.log(arguments)
	return this
}

const thisArg = { a: 1}

console.log(getThisBinding.bind(thisArg)) // getThisBinding
console.log(getThisBinding.bind(thisArg)()) // { a: 1 }</code>
        </deckgo-highlight-code>
<br />
그리고 bind 메서드는 메서드의 this와 메서드 내부의 중첩 함수 또는 콜백 함수의 this가 불일치하는 문제를 해결하기 위해 유용하게 사용된다.
<br />
<br />
<deckgo-highlight-code  terminal="carbon"  >
          <code slot="code">const person = {
	name: &#39;Lee&#39;,
    foo(callback) {
    	setTimeout((callback.bind(this), 100)
    }
}

person.foo(function () {
	console.log(this.name) // Lee
})</code>
        </deckgo-highlight-code>
<br />
<h2>이벤트 핸들러 안에서 쓴 this</h2>
<p>이벤트 핸들러 안에서 쓰는 this는 이벤트를 받는 HTML 요소를 가리킨다.
<br /></p>
<deckgo-highlight-code  terminal="carbon"  >
          <code slot="code">const button = document.querySelector(&#39;#btn&#39;)
button.addEventListener(&#39;click&#39;, function {
	console.log(this) // #btn
}</code>
        </deckgo-highlight-code>
<br />
하지만 화살표 함수의 경우 상위 스코프의 this인 window를 가리킨다.
<br />
<br />
<deckgo-highlight-code  terminal="carbon"  >
          <code slot="code">const button = document.querySelector(&#39;#btn&#39;)
button.addEventListener(&#39;click&#39;, () =&gt; {
	console.log(this) // window
}</code>
        </deckgo-highlight-code>
<br />
<blockquote>
<p>참고 자료
<a href="https://wikibook.co.kr/mjs/" target="_blank" rel="nofollow">모던 자바스크립트 Deep Dive</a></p>
</blockquote></div><style data-emotion="css jppgbf">.css-jppgbf{display:grid;place-items:center;margin-top:auto;padding:3.125rem 0;font-size:0.9375rem;text-align:center;line-height:1.5;}</style><div class="css-jppgbf evi8j960">Thank You for Visiting My Blog, Have a Good Day.<br/>@ 2022 Developer Jun, Powerd By Gatsby.</div></div></div><div id="gatsby-announcer" style="position:absolute;top:0;width:1px;height:1px;padding:0;overflow:hidden;clip:rect(0, 0, 0, 0);white-space:nowrap;border:0" aria-live="assertive" aria-atomic="true"></div></div><script id="gatsby-script-loader">/*<![CDATA[*/window.pagePath="/[js]_this/";window.___webpackCompilationHash="c673a20f55c061eb5938";/*]]>*/</script><script id="gatsby-chunk-mapping">/*<![CDATA[*/window.___chunkMapping={"polyfill":["/polyfill-4718f0fec20e0d09d7f5.js"],"app":["/app-f34191c66d70ce0253b2.js"],"component---src-pages-404-tsx":["/component---src-pages-404-tsx-5a1562b048caf7768ff8.js"],"component---src-pages-blog-tsx":["/component---src-pages-blog-tsx-892c8a8d330fbfc194c0.js"],"component---src-pages-index-tsx":["/component---src-pages-index-tsx-3257ada11e9e5e2624bb.js"],"component---src-templates-post-tsx":["/component---src-templates-post-tsx-268e05f5ac4790150225.js"]};/*]]>*/</script><script src="/polyfill-4718f0fec20e0d09d7f5.js" nomodule=""></script><script src="/component---src-templates-post-tsx-268e05f5ac4790150225.js" async=""></script><script src="/app-f34191c66d70ce0253b2.js" async=""></script><script src="/framework-6bdc9aaa9caa3de6408b.js" async=""></script><script src="/webpack-runtime-86f5ed40190be432559e.js" async=""></script></body></html>