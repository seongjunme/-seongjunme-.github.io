<!DOCTYPE html><html><head><meta charSet="utf-8"/><meta http-equiv="x-ua-compatible" content="ie=edge"/><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"/><meta name="generator" content="Gatsby 4.8.0"/><title data-react-helmet="true"></title><style>.gatsby-image-wrapper{position:relative;overflow:hidden}.gatsby-image-wrapper picture.object-fit-polyfill{position:static!important}.gatsby-image-wrapper img{bottom:0;height:100%;left:0;margin:0;max-width:none;padding:0;position:absolute;right:0;top:0;width:100%;object-fit:cover}.gatsby-image-wrapper [data-main-image]{opacity:0;transform:translateZ(0);transition:opacity .25s linear;will-change:opacity}.gatsby-image-wrapper-constrained{display:inline-block;vertical-align:top}</style><noscript><style>.gatsby-image-wrapper noscript [data-main-image]{opacity:1!important}.gatsby-image-wrapper [data-placeholder-image]{opacity:0!important}</style></noscript><script type="module">const e="undefined"!=typeof HTMLImageElement&&"loading"in HTMLImageElement.prototype;e&&document.body.addEventListener("load",(function(e){if(void 0===e.target.dataset.mainImage)return;if(void 0===e.target.dataset.gatsbyImageSsr)return;const t=e.target;let a=null,n=t;for(;null===a&&n;)void 0!==n.parentNode.dataset.gatsbyImageWrapper&&(a=n.parentNode),n=n.parentNode;const o=a.querySelector("[data-placeholder-image]"),r=new Image;r.src=t.currentSrc,r.decode().catch((()=>{})).then((()=>{t.style.opacity=1,o&&(o.style.opacity=0,o.style.transition="opacity 500ms linear")}))}),!0);</script><link as="script" rel="preload" href="/webpack-runtime-e0bfc4c4a39afd6169d6.js"/><link as="script" rel="preload" href="/framework-6bdc9aaa9caa3de6408b.js"/><link as="script" rel="preload" href="/app-f34191c66d70ce0253b2.js"/><link as="script" rel="preload" href="/component---src-templates-post-tsx-268e05f5ac4790150225.js"/><link as="fetch" rel="preload" href="/page-data/동기와비동기/page-data.json" crossorigin="anonymous"/><link as="fetch" rel="preload" href="/page-data/app-data.json" crossorigin="anonymous"/></head><body><div id="___gatsby"><div style="outline:none" tabindex="-1" id="gatsby-focus-wrapper"><style data-emotion="css 8ugl6e">.css-8ugl6e{display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-flex-direction:column;-ms-flex-direction:column;flex-direction:column;min-height:100vh;background-color:#121212;color:white;}.css-8ugl6e::-webkit-scrollbar-thumb{background-color:#ffffff;}</style><div class="css-8ugl6e ef79xez0"><style data-emotion="css-global 1llifsc">@import url(http://fonts.googleapis.com/css?family=Open+Sans:300italic,300);*{padding:0;margin:0;box-sizing:border-box;font-family:'Open Sans',Helvetica,sans-serif;font-weight:300;}html,body,#___gatsby{height:100%;}a,a:hover{color:inherit;-webkit-text-decoration:none;text-decoration:none;cursor:pointer;}</style><style data-emotion="css z5i94e">.css-z5i94e{position:relative;width:100%;height:350px;}</style><div class="css-z5i94e evp6fv50"><style data-emotion="css 1cf6hsn">.css-1cf6hsn{display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-flex-direction:column;-ms-flex-direction:column;flex-direction:column;width:768px;height:100%;margin:0 auto;padding:60px 0;color:#ffffff;}</style><div class="css-1cf6hsn e1x0sffc2"><style data-emotion="css 1pr6csa">.css-1pr6csa{overflow:hidden;overflow-wrap:break-word;margin-top:auto;text-overflow:ellipsis;white-space:normal;font-size:45px;font-weight:800;}</style><div class="css-1pr6csa e1x0sffc1">동기와 비동기</div><style data-emotion="css 15xrm5i">.css-15xrm5i{display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-flex-direction:column;-ms-flex-direction:column;flex-direction:column;-webkit-box-pack:start;-ms-flex-pack:start;-webkit-justify-content:flex-start;justify-content:flex-start;-webkit-box-pack:justify;-webkit-justify-content:space-between;justify-content:space-between;font-size:18px;font-weight:700;}.css-15xrm5i div{margin-top:10px;}</style><div class="css-15xrm5i e1x0sffc0"><div>2021.08.06.</div><div>CS</div></div></div></div><style data-emotion="css n1la39">.css-n1la39{display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-flex-direction:column;-ms-flex-direction:column;flex-direction:column;width:768px;margin:0 auto;word-break:break-all;line-height:1.8;font-size:1.125rem;font-weight:400;color:#ececec;}.css-n1la39 p{padding:3px 0;}.css-n1la39 h1,.css-n1la39 h2,.css-n1la39 h3,.css-n1la39 h4{margin:2.414rem 0 1rem;font-weight:inherit;line-height:1.42;}.css-n1la39 h1{font-size:3.598rem;}.css-n1la39 h2{font-size:2.827rem;}.css-n1la39 h3{font-size:1.999rem;}.css-n1la39 h4{font-size:1.414rem;}.css-n1la39 h5{font-size:1.121rem;}.css-n1la39 h6{font-size:0.88rem;}.css-n1la39 blockquote{margin:10px 0;border-left:5px solid #7a7a7a;font-style:italic;padding:5px 15px;text-align:left;background-color:#1e1e1e;}.css-n1la39 aside{background-color:#1e1e1e;margin:10px 0;}.css-n1la39 table{background-color:#22272e;border-collapse:collapse;}.css-n1la39 table th,.css-n1la39 table td{padding:6px 13px;}.css-n1la39 table th:not(first-child),.css-n1la39 table td:not(first-child){border:1px solid #444c56;}.css-n1la39 ol,.css-n1la39 ul{margin-left:20px;padding:10px 0;}.css-n1la39 hr{margin:30px 0;background:#4d4d4d;border:none;height:1px;width:100%;}.css-n1la39 a:link{-webkit-text-decoration:none;text-decoration:none;text-shadow:0 0 24px;}.css-n1la39 a:hover{color:#4263eb;}.css-n1la39 strong{font-weight:bold;}.css-n1la39 deckgo-highlight-code{font-size:14px;}</style><div class="css-n1la39 era8a5j0"><h2>동기와 비동기</h2>
<hr>
<blockquote>
<p>동기는 순차적으로 테스크를 수행하고, 비동기는 병렬적으로 수행한다.</p>
</blockquote>
<h3>동기 (Synchronous)</h3>
<hr>
<ul>
<li>동기는 요청을 보낸 후 응답을 받아야지만 다음 동작이 이루어지는 방식을 말한다. 모든 일은 순차적으로 실행되며 어떤 작업이 수행 중이라면 다음 작업은 대기한다.</li>
<li>예를 들자면, 카페에서 주문을 하나 받고 음료 제조하고, 다시 주문 하나 받고 음료 제조하는 방식이다.</li>
</ul>
<deckgo-highlight-code language="jsx" terminal="carbon"  >
          <code slot="code">const f1 = () =&gt; {
  console.log(&#39;hello&#39;);
  f2();
};

const f2 = () =&gt; {
  console.log(&#39;world&#39;);
  f3();
};

const f3 = () =&gt; {
  console.log(&#39;!!&#39;);
};

f1(); //f1 -&gt; f2 -&gt; f3</code>
        </deckgo-highlight-code>
<h3>비동기 (Asynchronous)</h3>
<hr>
<ul>
<li>비동기는 요청을 일단 다 받은 다음에, 요청이 끝나면 테스크가 순차적으로 수행되는 방식이다.</li>
<li>예를 들자면, 카페에서 주문을 모두 받은 뒤, 음료를 제조하는 방식이다.</li>
</ul>
<deckgo-highlight-code language="jsx" terminal="carbon"  >
          <code slot="code">const f1 = () =&gt; {
  console.log(&#39;hello&#39;);
  f2();
};

const f2 = () =&gt; {
  setTimeout(() =&gt; {
    console.log(&#39;world&#39;);
  });
  f3();
};

const f3 = () =&gt; {
  console.log(&#39;!!&#39;);
};

f1(); //f1 -&gt; f3 -&gt; f2</code>
        </deckgo-highlight-code>
<h4>비동기 처리는 왜 필요한가?</h4>
<ul>
<li>데이터를 서버로부터 받아오는 앱을 만든다고 가정해보자.
서버로부터 데이터를 받아와서 해당 데이터를 처리해야하므로, 데이터를 받아오는 코드는 제일 상단에 위치할 것이다.</li>
<li>이때, 비동기로 처리하지 않고 동기적으로 처리한다면, 데이터를 받아올 때까지 기다린 다음에 다음 코드가 실행될 것이다.</li>
<li>만약 받아올 데이터의 크기가 크다면, 그 동안 앱은 멈춰있을 것이다.</li>
<li>따라서 이러한 불편함을 없애기 위해, 데이터의 수신같은 기다려야하는 코드들은 비동기적으로 처리한다.</li>
</ul>
<h3>자바스크립트에서 비동기</h3>
<hr>
<h4>비동기 처리를 위한 콜백 패턴의 단점</h4>
<ul>
<li>자바스크립트에서 비동기 처리를 위해 클로저나 람다식을 인자로 넣어 콜백 처리를 수행한다.</li>
<li>만약 이 콜백 처리의 양이 상당이 많아진다면, 콜백 헬 ( 콜백 함수 호출이 중첩되어 복잡도가 높아지는 현상)이 발생하고, 이는 에러처리 또한 힘들게 된다.</li>
<li>콜백 헬</li>
</ul>
<p><img src="https://user-images.githubusercontent.com/72444675/159239643-b3cf5d15-270c-43e9-a8d9-c11bf55c8c1d.jpeg" alt="다운로드_(8)"></p>
<h4>Promise</h4>
<ul>
<li>
<p>위의 콜백 헬을 극복하기 위해 ES6에서 Promise가 도입되었다</p>
<deckgo-highlight-code language="jsx" terminal="carbon"  >
          <code slot="code">const promise = new Promise((resolve, reject) =&gt; {
	// 콜백 함수 내부에서 비동기 처리를 수행한다.
	if (// 비동기 처리 성공) {
		resolve(&#39;success&#39;);
	} else { // 비동기 처리 실패
		reject(&#39;fail&#39;);
	}
}

promise
	.then(value =&gt; {
		console.log(value); //success 출력
	})
	.catch(error =&gt; {
		console.log(error);
	})</code>
        </deckgo-highlight-code>
</li>
<li>
<p>Promise란 내용이 실행은 되었지만 결과를 아직 반환하지 않은 객체를 의미한다.</p>
</li>
<li>
<p>즉 위의 promise변수에 Promise객체가 저장되고, 이는 나중에 결과 값을 가져와 사용할 수 있다는 것을 의미한다.</p>
</li>
<li>
<p>그리고 Promise를 생성할 때, 콜백 함수를 인자로 넘겨 주는데, 그 콜백안에 두 개의 콜백함수를 또 넘겨준다. (resolve, reject)</p>
</li>
<li>
<p>이 두 콜백은 각각 비동기 처리의 성공, 실패 여부에 따라 수행된다.</p>
</li>
<li>
<p>만약 성공했다면 resolve 함수를 통해 success라는 메시지가 전달된다.</p>
</li>
<li>
<p>이렇게 생성한 프로미스를 사용하기 위해서 then이라는 기능을 사용한다.</p>
</li>
<li>
<p>then에서 value는 resolve에서 전달한 메시지가 전달된다.</p>
</li>
<li>
<p>만약 resolve가 아니라 reject (실패)라면 then 이 아닌 catch를 이용하여 진행한다.</p>
</li>
</ul>
<h4>Promise Chaining</h4>
<ul>
<li>순차적으로 처리해야하는 비동기 작업이 여러개 있다고 할 때, Promise Chaining을 한다면 이를 해결할 수 있다.</li>
</ul>
<deckgo-highlight-code language="jsx" terminal="carbon"  >
          <code slot="code">const fetchNumber = new Promise((resolve, reject) =&gt; {
  setTimeout(() =&gt; resolve(1), 1000); // (*)
});

fetchNumber
  .then(num =&gt; num * 2) // (**)
  .then(num =&gt; num * 2) // (***)
  .then(num =&gt; {
    return new Promise((resolve, reject) =&gt; {
      setTimeout(() =&gt; resolve(num), 1000);
    });
  })
  .then(num =&gt; console.log(num)); // 4</code>
        </deckgo-highlight-code>
<ol>
<li>1초 후 최초 프라미스가 이행됩니다. – <code class="language-text">(*)</code></li>
<li>이후 첫번째 <code class="language-text">.then</code> 핸들러가 호출됩니다. –<code class="language-text">(**)</code></li>
<li>2에서 반환한 값은 다음 <code class="language-text">.then</code> 핸들러에 전달됩니다. – <code class="language-text">(***)</code></li>
<li>이런 과정이 계속 이어집니다.</li>
</ol>
<p><img src="https://user-images.githubusercontent.com/72444675/159239705-13c0985f-25dc-44d5-8e5b-88228ed1f9be.png" alt="스크린샷_2021-08-04_오전_12 45 20"></p>
<ul>
<li>프로미스 체이닝이 가능한 이유는 then을 호출하면 프로미스가 반환되기 때문입니다.</li>
</ul></div><style data-emotion="css jppgbf">.css-jppgbf{display:grid;place-items:center;margin-top:auto;padding:3.125rem 0;font-size:0.9375rem;text-align:center;line-height:1.5;}</style><div class="css-jppgbf evi8j960">Thank You for Visiting My Blog, Have a Good Day.<br/>@ 2022 Developer Jun, Powerd By Gatsby.</div></div></div><div id="gatsby-announcer" style="position:absolute;top:0;width:1px;height:1px;padding:0;overflow:hidden;clip:rect(0, 0, 0, 0);white-space:nowrap;border:0" aria-live="assertive" aria-atomic="true"></div></div><script id="gatsby-script-loader">/*<![CDATA[*/window.pagePath="/동기와비동기/";window.___webpackCompilationHash="f063eb4cbaa6c8e2e10d";/*]]>*/</script><script id="gatsby-chunk-mapping">/*<![CDATA[*/window.___chunkMapping={"polyfill":["/polyfill-4718f0fec20e0d09d7f5.js"],"app":["/app-f34191c66d70ce0253b2.js"],"component---src-pages-404-tsx":["/component---src-pages-404-tsx-5a1562b048caf7768ff8.js"],"component---src-pages-blog-tsx":["/component---src-pages-blog-tsx-892c8a8d330fbfc194c0.js"],"component---src-pages-index-tsx":["/component---src-pages-index-tsx-def145fc02d2de2741cd.js"],"component---src-templates-post-tsx":["/component---src-templates-post-tsx-268e05f5ac4790150225.js"]};/*]]>*/</script><script src="/polyfill-4718f0fec20e0d09d7f5.js" nomodule=""></script><script src="/component---src-templates-post-tsx-268e05f5ac4790150225.js" async=""></script><script src="/app-f34191c66d70ce0253b2.js" async=""></script><script src="/framework-6bdc9aaa9caa3de6408b.js" async=""></script><script src="/webpack-runtime-e0bfc4c4a39afd6169d6.js" async=""></script></body></html>