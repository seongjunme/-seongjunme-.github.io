<!DOCTYPE html><html><head><meta charSet="utf-8"/><meta http-equiv="x-ua-compatible" content="ie=edge"/><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"/><meta name="generator" content="Gatsby 4.8.0"/><title data-react-helmet="true"></title><style>.gatsby-image-wrapper{position:relative;overflow:hidden}.gatsby-image-wrapper picture.object-fit-polyfill{position:static!important}.gatsby-image-wrapper img{bottom:0;height:100%;left:0;margin:0;max-width:none;padding:0;position:absolute;right:0;top:0;width:100%;object-fit:cover}.gatsby-image-wrapper [data-main-image]{opacity:0;transform:translateZ(0);transition:opacity .25s linear;will-change:opacity}.gatsby-image-wrapper-constrained{display:inline-block;vertical-align:top}</style><noscript><style>.gatsby-image-wrapper noscript [data-main-image]{opacity:1!important}.gatsby-image-wrapper [data-placeholder-image]{opacity:0!important}</style></noscript><script type="module">const e="undefined"!=typeof HTMLImageElement&&"loading"in HTMLImageElement.prototype;e&&document.body.addEventListener("load",(function(e){if(void 0===e.target.dataset.mainImage)return;if(void 0===e.target.dataset.gatsbyImageSsr)return;const t=e.target;let a=null,n=t;for(;null===a&&n;)void 0!==n.parentNode.dataset.gatsbyImageWrapper&&(a=n.parentNode),n=n.parentNode;const o=a.querySelector("[data-placeholder-image]"),r=new Image;r.src=t.currentSrc,r.decode().catch((()=>{})).then((()=>{t.style.opacity=1,o&&(o.style.opacity=0,o.style.transition="opacity 500ms linear")}))}),!0);</script><link as="script" rel="preload" href="/webpack-runtime-590151b474144b6535f0.js"/><link as="script" rel="preload" href="/framework-6bdc9aaa9caa3de6408b.js"/><link as="script" rel="preload" href="/app-f34191c66d70ce0253b2.js"/><link as="script" rel="preload" href="/component---src-templates-post-tsx-cdd982b2742c5fa0a328.js"/><link as="fetch" rel="preload" href="/page-data/객체지향/page-data.json" crossorigin="anonymous"/><link as="fetch" rel="preload" href="/page-data/app-data.json" crossorigin="anonymous"/></head><body><div id="___gatsby"><div style="outline:none" tabindex="-1" id="gatsby-focus-wrapper"><style data-emotion="css rmgwh1">.css-rmgwh1{display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-flex-direction:column;-ms-flex-direction:column;flex-direction:column;height:100%;background-color:#121212;color:white;}.css-rmgwh1::-webkit-scrollbar-thumb{background-color:#ffffff;}</style><div class="css-rmgwh1 ef79xez0"><style data-emotion="css-global 1llifsc">@import url(http://fonts.googleapis.com/css?family=Open+Sans:300italic,300);*{padding:0;margin:0;box-sizing:border-box;font-family:'Open Sans',Helvetica,sans-serif;font-weight:300;}html,body,#___gatsby{height:100%;}a,a:hover{color:inherit;-webkit-text-decoration:none;text-decoration:none;cursor:pointer;}</style><style data-emotion="css z5i94e">.css-z5i94e{position:relative;width:100%;height:350px;}</style><div class="css-z5i94e evp6fv50"><style data-emotion="css 1cf6hsn">.css-1cf6hsn{display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-flex-direction:column;-ms-flex-direction:column;flex-direction:column;width:768px;height:100%;margin:0 auto;padding:60px 0;color:#ffffff;}</style><div class="css-1cf6hsn e1x0sffc2"><style data-emotion="css 1pr6csa">.css-1pr6csa{overflow:hidden;overflow-wrap:break-word;margin-top:auto;text-overflow:ellipsis;white-space:normal;font-size:45px;font-weight:800;}</style><div class="css-1pr6csa e1x0sffc1">객체지향</div><style data-emotion="css 15xrm5i">.css-15xrm5i{display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-flex-direction:column;-ms-flex-direction:column;flex-direction:column;-webkit-box-pack:start;-ms-flex-pack:start;-webkit-justify-content:flex-start;justify-content:flex-start;-webkit-box-pack:justify;-webkit-justify-content:space-between;justify-content:space-between;font-size:18px;font-weight:700;}.css-15xrm5i div{margin-top:10px;}</style><div class="css-15xrm5i e1x0sffc0"><div>2021.07.29.</div><div>CS</div></div></div></div><style data-emotion="css n1la39">.css-n1la39{display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-flex-direction:column;-ms-flex-direction:column;flex-direction:column;width:768px;margin:0 auto;word-break:break-all;line-height:1.8;font-size:1.125rem;font-weight:400;color:#ececec;}.css-n1la39 p{padding:3px 0;}.css-n1la39 h1,.css-n1la39 h2,.css-n1la39 h3,.css-n1la39 h4{margin:2.414rem 0 1rem;font-weight:inherit;line-height:1.42;}.css-n1la39 h1{font-size:3.598rem;}.css-n1la39 h2{font-size:2.827rem;}.css-n1la39 h3{font-size:1.999rem;}.css-n1la39 h4{font-size:1.414rem;}.css-n1la39 h5{font-size:1.121rem;}.css-n1la39 h6{font-size:0.88rem;}.css-n1la39 blockquote{margin:10px 0;border-left:5px solid #7a7a7a;font-style:italic;padding:5px 15px;text-align:left;background-color:#1e1e1e;}.css-n1la39 aside{background-color:#1e1e1e;margin:10px 0;}.css-n1la39 table{background-color:#22272e;border-collapse:collapse;}.css-n1la39 table th,.css-n1la39 table td{padding:6px 13px;}.css-n1la39 table th:not(first-child),.css-n1la39 table td:not(first-child){border:1px solid #444c56;}.css-n1la39 ol,.css-n1la39 ul{margin-left:20px;padding:10px 0;}.css-n1la39 hr{margin:30px 0;background:#4d4d4d;border:none;height:1px;width:100%;}.css-n1la39 a:link{-webkit-text-decoration:none;text-decoration:none;text-shadow:0 0 24px;}.css-n1la39 a:hover{color:#4263eb;}.css-n1la39 strong{font-weight:bold;}.css-n1la39 deckgo-highlight-code{font-size:14px;}</style><div class="css-n1la39 era8a5j0"><h1>1. 객체지향</h1>
<hr>
<h2>1.1 클래스 vs 객체 vs 인스턴스</h2>
<hr>
<ul>
<li>
<p>클래스란?</p>
<ul>
<li>공통된 속성과 행위를 수행하는 객체의 집합이다. 즉 객체를 정의하고 만들어 내기 위한 설계도</li>
</ul>
<deckgo-highlight-code language="jsx" terminal="carbon"  >
          <code slot="code">class 사람 {
	나이: ;
	성별: ;

	인사 () {
		안녕하세요..
	}
}</code>
        </deckgo-highlight-code>
<p>클래스는 속성을 나타내는 필드와, 행위를 나타내는 메소드로 구성된다.</p>
</li>
<li>
<p>객체란?</p>
<ul>
<li>클래스로 구현한 실체된 대상이다.</li>
<li>즉, ‘나’는 사람이라는 클래스의 객체라고 볼 수 있다.</li>
<li>객체는 클래스의 인스턴스라고 부른다.</li>
</ul>
</li>
<li>
<p>인스턴스란?</p>
<ul>
<li>클래스 설계도를 바탕으로 소프트웨어에서 구현된 구체적인 실체이다.</li>
<li>즉, 객체를 소프트웨어에서 실체화 하면 그것을 <strong>인스턴스</strong>라고 부른다.</li>
<li>실체화된 인스턴스는 메모리에 할당된다.</li>
</ul>
</li>
<li>
<p>객체 vs 인스턴스</p>
<ul>
<li>클래스 타입으로 선언한 것을 객체라 하고, 그 객체가 메모리에 할당 되어질때 (new) 인스턴스라고 한다.</li>
<li>객체는 현실세계에 가깝고, 인스턴스는 관계의 초점에 가까운 개념</li>
</ul>
</li>
</ul>
<h2>1.2 상속과 다형성</h2>
<hr>
<ul>
<li>
<p><strong>상속</strong>
객체지향에서 상속이란 어떤 클래스보다 좀 더 확장된 기능을 구현하고 싶을 때 새로 클래스를 구현하지 않고, 기존의 클래스를 상속받아서 속성이나 기능을 확장시키는 것을 말한다.</p>
</li>
<li>
<p><strong>다형성</strong></p>
<p>다형성이란 하나의 객체가 여러 가지 타입을 가질 수 있다는 것을 의미한다.</p>
<p>예를 들어 상속을 이용한다면, 부모 클래스 타입의 참조 변수로 자식 클래스 타입의 인스턴스를 참조할 수 있도록 할 수 있다.</p>
</li>
<li>
<p><strong>오버로딩(Overloading) vs 오버라이딩(Overriding)</strong></p>
<ul>
<li>오버로딩: 같은 이름의 메서드를 여러개 가지면서 매개변수의 유형과 개수가 다르게 하는 방법</li>
</ul>
<deckgo-highlight-code language="jsx" terminal="carbon"  >
          <code slot="code">class OverloadingTest{
    cat(){
        console.log(&quot;매개변수 없음&quot;);
    }

    cat(int a, int b){
        console.log(&quot;매개변수 :&quot;+a+&quot;, &quot;+b);
    }

    cat(String c){
        console.log(&quot;매개변수 : &quot;+ c);
    }
}
</code>
        </deckgo-highlight-code>
<p>출처: <a href="https://private.tistory.com/25" target="_blank" rel="nofollow">https://private.tistory.com/25</a> [공부해서 남 주자]</p>
  <br />
<ul>
<li>
<p>오버라이딩: 상위 클래스가 가지고 있는 메서드를 하위 클래스가 재정의 해서 사용하는 방법</p>
<deckgo-highlight-code language="jsx" terminal="carbon"  >
          <code slot="code">class Woman{
	constructor() {
	    this.name;
	    this.age;
    }
    info(){
        console.log(&quot;여자의 이름은 &quot;+name+&quot;, 나이는 &quot;+age+&quot;살입니다.&quot;);
    }

}

class Job extends Woman{
	 constructor() {
	    this.job;
    }
    info() {
        super.info();
        console.log(&quot;여자의 직업은 &quot;+job+&quot;입니다.&quot;);
    }
}

출처: https://private.tistory.com/25 [공부해서 남 주자]</code>
        </deckgo-highlight-code>
</li>
</ul>
</li>
<li>
<p><strong>this vs super</strong>
this란 현재 클래스의 인스턴스를 의미하고, super란 상위 클래스의 인스턴스를 의미한다.</p>
</li>
</ul>
<h1>2. 자바스크립트에서 객체지향</h1>
<hr>
<h2>2.1 object literal</h2>
<hr>
<p>자바스크립트는 오브젝트를 이용하여 객체를 표현할 수 있다.</p>
<deckgo-highlight-code language="jsx" terminal="carbon"  >
          <code slot="code">const person = {
  name: &#39;곽성준&#39;,
  Age: 24,

  info() {
    console.log(&#39;이름: &#39; + this.name + &#39;나이: &#39; + this.age);
  },
};

person.info();</code>
        </deckgo-highlight-code>
<h2>2.2 Class (ES2016)</h2>
<hr>
<p>class가 생기고 class에서 제공하는 constructor라는 생성자가 주어짐.</p>
<p>class를 new로 호출하면 생성자가 실행되고, 인스턴스를 반환한다.</p>
<p>하지만 class는 prototype을 내부적으로 사용하고 있다.</p>
<deckgo-highlight-code language="jsx" terminal="carbon"  >
          <code slot="code">class Person {
  constructor(name, age) {
    this.name = name;
    this.age = age;
  }
  info() {
    console.log(&#39;이름: &#39; + this.name + &#39;나이: &#39; + this.age);
  }
}

const person = new Person(&#39;곽성준&#39;, 24);
person.info();</code>
        </deckgo-highlight-code>
<h2>2.3 constructor pattern</h2>
<hr>
<p>function을 new 키워드로 호출하면 그 함수는 constructor가 된다.</p>
<deckgo-highlight-code language="jsx" terminal="carbon"  >
          <code slot="code">const Person = function(name, age) {
		this.name = name;
		this.age = age
		this.info() = function {
		    console.log(&#39;이름: &#39; + this.name + &#39;나이: &#39; + this.age);
	  }
}

const person = new Person(&#39;곽성준&#39;, 24);
person.info();</code>
        </deckgo-highlight-code>
<h2>2.4 prototype</h2>
<hr>
<p>constructor 패턴과 유사하나, 메서드를 prototype객체에 보관해서 메모리 효율성에서 유리하다.</p>
<ul>
<li>자바스크립트에서 함수를 정의하고, 파싱 단계에 들어가면 내부적으로 수행되는 작업이 있다.</li>
<li>함수 멤버로 prototype 속성이 생기고, 이 속성은 다른 곳에 생성된 함수이름의 프로토타입 객체를 참조한다.</li>
</ul>
<hr>
<ul>
<li>예를 들어 아래의 함수를 정의했다고 하자.</li>
</ul>
<deckgo-highlight-code language="jsx" terminal="carbon"  >
          <code slot="code">function Person() {}</code>
        </deckgo-highlight-code>
<ul>
<li>속성이 하나도 없는 Person함수가 정의되고, 파싱단계에 들어가면, Person 함수 Prototype 속성은 프로토타입 객체를 참조한다.</li>
<li>그리고 프로토타입 객체 멤버인 constructor 속성은 Person함수를 참조하는 구조를 가진다.</li>
</ul>
<p><img src="https://user-images.githubusercontent.com/72444675/157591335-ca2ec2f2-fb11-47b8-8242-dc06880641e3.png" alt="스크린샷_2021-07-28_오전_12 11 54"></p>
<hr>
<ul>
<li>여기서 person 프로토타입 객체는 new라는 연산자와 Person함수를 통해 생성된 모든 객체의 원형이 되는 객체이다.</li>
<li>예를 들어 Person함수를 new연산자를 이용해 생성한다면 아래와 같이 같은 프로토타입 객체를 참조한다.</li>
</ul>
<deckgo-highlight-code language="jsx" terminal="carbon"  >
          <code slot="code">function Person() {}

const joon = new Person();
const jisoo = new Person();</code>
        </deckgo-highlight-code>
<br />
<p><img src="https://user-images.githubusercontent.com/72444675/157591360-c8d1a3e9-8a6d-4330-9e1b-2191350f029e.png" alt="스크린샷_2021-07-28_오전_12 15 36"></p>
<ul>
<li><strong>proto</strong> 란 비표준 속성이고, 이는 원형인 프로토타입 객체를 숨은 링크로 참조하는 역할을 한다.</li>
</ul>
<hr>
<ul>
<li>모든 객체는 프로토타입 객체에 접근할 수 있고, 프로토타입 객체 또한 동적으로 멤버를 가질 수 있다.</li>
<li>예를 들어 아래와 같이 런타임에 멤버를 추가할 수 있다.</li>
</ul>
<deckgo-highlight-code language="jsx" terminal="carbon"  >
          <code slot="code">function Person() {}

const joon = new Person();
const jisoo = new Person();

Person.prototype.getType = function () {
  return &#39;인간&#39;;
};

console.log(joon.getType()); //인간
console.log(jisoo.getType()); //인간</code>
        </deckgo-highlight-code>
<br />
<p><img src="https://user-images.githubusercontent.com/72444675/157591398-4cef7c9b-2229-43f5-85f9-2bd49fe6e245.png" alt="스크린샷_2021-07-28_오전_12 20 46"></p>
<hr>
<ul>
<li>만약 동적으로 멤버를 추가할 때 프로토타입 객체를 사용하지 않는 다면 프로토타입 객체가 아닌 각각의 객체 안에 멤버가 추가된다.</li>
</ul>
<deckgo-highlight-code language="jsx" terminal="carbon"  >
          <code slot="code">joon.getType = function () {
  return &#39;사람&#39;;
};

console.log(joon.getType()); //사람
console.log(jisoo.getType()); //인간

jisso.age = 25;

console.log(joon.age); // undefined
console.log(jisoo.age); // 25</code>
        </deckgo-highlight-code>
<br />
<p><img src="https://user-images.githubusercontent.com/72444675/157591460-2703e7e9-caaf-4350-9ac1-0b4cdd3fd210.png" alt="스크린샷_2021-07-28_오전_12 23 58"></p>
<ul>
<li>따라서 프로토타입 패턴을 사용하면 메서드를 따로 보관하지 않고, 프로토타입 객체에 보관해서 메모리 효율이 더 좋다.</li>
</ul>
<h2>2.5 class기반 vs prototype기반</h2>
<hr>
<ul>
<li>클래스
<ul>
<li>클래스는 객체의 기본적인 구조와 기능을 먼저 정의한다.</li>
<li>인스턴스는 특정 클래스의 양식을 기반으로 한다.</li>
<li>즉, 모든 인스턴스의 구조는 동일하다.</li>
</ul>
</li>
<li>프로토타입
<ul>
<li>클래스는 클래스 사이의 분류 관계에 초점을 맞추지만, 프로토타입은 여러가지 표본의 동작 방식에 초점을 맞춘다.</li>
<li>프로토타입 기반 체계는 동적으로 구조를 정의할 수 있다.</li>
</ul>
</li>
</ul>
<h1>3. 객체지향 설계 (SOLID)</h1>
<hr>
<h2>3.1 SRP (단일 책임 원칙)</h2>
<hr>
<ul>
<li>한 클래스는 하나의 책임만 가져야 하며, 그 기능을 완전히 캡슐화해야 한다.</li>
<li>이는 어떤 변화에 의해 클래스를 변경해야 하는 이유는 오직 하나뿐이어야함을 의미한다.</li>
<li>SRP는 책임 영역이 확실하기 때문에 다른 클래스와의 연쇄작용에서 자유로울 수 있다.</li>
<li>따라서 코드의 가독성 향상, 재사용성 증진, 유지보수 용이라는 이점이 있다.</li>
</ul>
<h2>3.2 LSP (리스코프 치환 원칙)</h2>
<hr>
<ul>
<li>프로그램의 객체는 프로그램의 정확성을 깨뜨리지 않으면서 하위 타입의 인스턴스로 바꿀 수 있어야 한다</li>
<li>즉, 서브 타입은 언제나 기반 타입으로 교체할 수 있어야 한다.</li>
<li>이는 다형성을 증진시키기 위한 목적이다.</li>
</ul>
<p><a href="https://medium.com/humanscape-tech/solid-%EB%B2%95%EC%B9%99-%E4%B8%AD-lid-fb9b89e383ef" target="_blank" rel="nofollow">리스코프 치환 원칙 예시</a></p></div><style data-emotion="css c5tzst">.css-c5tzst{display:grid;place-items:center;margin-top:auto;padding:50px 0;font-size:15px;text-align:center;line-height:1.5;}</style><div class="css-c5tzst evi8j960">Thank You for Visiting My Blog, Have a Good Day.<br/>@ 2022 Developer Jun, Powerd By Gatsby.</div></div></div><div id="gatsby-announcer" style="position:absolute;top:0;width:1px;height:1px;padding:0;overflow:hidden;clip:rect(0, 0, 0, 0);white-space:nowrap;border:0" aria-live="assertive" aria-atomic="true"></div></div><script id="gatsby-script-loader">/*<![CDATA[*/window.pagePath="/객체지향/";window.___webpackCompilationHash="488dfcbe64d956b407b4";/*]]>*/</script><script id="gatsby-chunk-mapping">/*<![CDATA[*/window.___chunkMapping={"polyfill":["/polyfill-4718f0fec20e0d09d7f5.js"],"app":["/app-f34191c66d70ce0253b2.js"],"component---src-pages-404-tsx":["/component---src-pages-404-tsx-5a1562b048caf7768ff8.js"],"component---src-pages-blog-tsx":["/component---src-pages-blog-tsx-0495f90534ea9d80a60f.js"],"component---src-pages-index-tsx":["/component---src-pages-index-tsx-5bacc024ada3b80ea810.js"],"component---src-templates-post-tsx":["/component---src-templates-post-tsx-cdd982b2742c5fa0a328.js"]};/*]]>*/</script><script src="/polyfill-4718f0fec20e0d09d7f5.js" nomodule=""></script><script src="/component---src-templates-post-tsx-cdd982b2742c5fa0a328.js" async=""></script><script src="/app-f34191c66d70ce0253b2.js" async=""></script><script src="/framework-6bdc9aaa9caa3de6408b.js" async=""></script><script src="/webpack-runtime-590151b474144b6535f0.js" async=""></script></body></html>