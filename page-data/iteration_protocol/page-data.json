{
    "componentChunkName": "component---src-templates-post-tsx",
    "path": "/iteration_protocol/",
    "result": {"data":{"allMarkdownRemark":{"edges":[{"node":{"html":"<h1>ES5에서의 리스트 순회</h1>\n<p>ES6의 달라진 리스트 순회 방법을 알아보기 앞서 기존의 방식을 먼저 소개해본다.</p>\n<br />\n<deckgo-highlight-code  terminal=\"carbon\"  >\n          <code slot=\"code\">var arr = [1, 2, 3, 4]\n\nfor (var i=0; i&lt;arr.length; i++) {\n\tconsole.log(arr[i])\n}</code>\n        </deckgo-highlight-code>\n<br />\n<p>기존 ES5에서는 C와 유사하게 리스트의 index(key) 값을 이용하여 접근하는 방식이었다.</p>\n<h1>ES6 에서 달라진 리스트 순회</h1>\n<br />\n<deckgo-highlight-code  terminal=\"carbon\"  >\n          <code slot=\"code\">const arr = [1, 2, 3, 4]\n\nfor (const a of arr) {\n\tconsole.log(a)\n}</code>\n        </deckgo-highlight-code>\n<br />\n<p>상당히 직관적으로 바뀐 모습을 볼 수 있다.\n그렇다면 바뀐 순회 방법이 내부적으로는 ES5 방식을 따르고 추상화한 것일까?</p>\n<p>다음 코드를 보면 아니라는 것을 알 수 있다.</p>\n<br />\n<deckgo-highlight-code  terminal=\"carbon\"  >\n          <code slot=\"code\">const map = new Map([&#39;a&#39;, 1&#39;], [&#39;b&#39;, 2], [&#39;c&#39;, 3])\n\nfor (const m of map) {\n\tconsole.log(m)\n}\n\nconsole.log()\n\nfor (let i=0; i&lt;map.length; i++) {\n\tconsole.log(map[i])\n}\n\n\n[&#39;a&#39;, 1]\n[&#39;b&#39;, 2]\n[&#39;c&#39;, 3]\n\nundefined\nundefined\nundefined</code>\n        </deckgo-highlight-code>\n<br />\n<p>기존 순회 방법(ES5)으로 순회되지 않는 Map 객체가 새로운 순회 방법(ES6)으로는 순회되는 것을 볼 수 있다. 이러한 사실을 봤을 때, ES6 순회 방식이 기존 ES5 방식을 따르지 않는다는 것을 알 수 있다.</p>\n<p>그렇다면 ES6는 어떠한 방식으로 순회하는 것일까?</p>\n<h1>Symbol.iterator</h1>\n<p>ES6 iterable은 모두 Symbol.iterator를 가지고 있다.\n즉, Symbol.iterator 프로퍼티를 가진 객체를 이터러블이라고 한다.</p>\n<br />\n<deckgo-highlight-code  terminal=\"carbon\"  >\n          <code slot=\"code\">const arr = [1, 2, 3, 4]\nconsole.log(arr[Symbol.iterator])\n\n// ƒ values() { [native code] }</code>\n        </deckgo-highlight-code>\n<br />\n<p>기존의 순회 가능한 데이터 컬렉션들은 통일된 규약 없이 각자의 방식대로 순회할 수 있었다.\n따라서 ES6에서는 데이터 컬렉션들을 순회하는 방법을 통일 시켰다고 볼 수 있다.</p>\n<p>그래서 이 Symbol.iterator를 갖는 데이터 컬렉션의 순회 방법은 무엇인가?</p>\n<p>우선 이 Symbol.iterator를 할당받아 실행시켜보자.</p>\n<br />\n<deckgo-highlight-code  terminal=\"carbon\"  >\n          <code slot=\"code\">const arr = [1, 2, 3, 4]\nconst iterable = arr[Symbol.iterator]()\nconsole.log(iterable)\n\n// Array Iterator {}</code>\n        </deckgo-highlight-code>\n<br />\n<p>어떠한 array iterator 라는 객체가 반환되었다.\n그리고 이 객체에는 다음과 같은 메소드를 가지고 있었다.</p>\n<br />\n<deckgo-highlight-code  terminal=\"carbon\"  >\n          <code slot=\"code\">const arr = [1, 2, 3, 4]\nconst iterable = arr[Symbol.iterator]()\niterable.next()\n\n// {value: 1, done: false}</code>\n        </deckgo-highlight-code>\n<br />\n<p>value가 arr의 첫 번째 값을 의미하고 있었다.\n즉 또 다시 iterable.next()를 호출하면</p>\n<br />\n<deckgo-highlight-code  terminal=\"carbon\"  >\n          <code slot=\"code\">iterable.next()\n\n// {value: 2, done: false}</code>\n        </deckgo-highlight-code>\n<br />\n<p>다음 값인 2가 호출되고, 계속 반복한다면</p>\n<br />\n<deckgo-highlight-code  terminal=\"carbon\"  >\n          <code slot=\"code\">iterable.next()\n// {value: 3, done: false}\n\niterable.next()\n// {value: 4, done: false}\n\niterable.next()\n// {value: undefined, done: true}</code>\n        </deckgo-highlight-code>\n<br />\n<p>arr의 끝까지 순회하게 되고, 더 이상 순회할 값이 없으면 done이 true가 된다.</p>\n<p>즉 ES6의 iterable은 이러한 방식으로 순회를 한다.</p>\n<p>또 한가지 신기한 사실은 next()를 호출한뒤 for of문을 사용하게 되면, next() 이후의 값이 순회된다.</p>\n<br />\n<deckgo-highlight-code  terminal=\"carbon\"  >\n          <code slot=\"code\">const arr = [1, 2, 3, 4]\nconst iterable = arr[Symbol.iterator]()\niterable.next()\n\nfor (const a of iterable) {\n\tconsole.log(a)\n}\n\n2\n3\n4\n</code>\n        </deckgo-highlight-code>\n<br />\n<h1>사용자 정의 iterableå</h1>\n<p>ES6의 내장 iterable (arr, set, map 등등)이외에 일반 객체도 iteration protocol을 준수하도록 구현하려면 어떻게 해야할까?</p>\n<br />\n<deckgo-highlight-code  terminal=\"carbon\"  >\n          <code slot=\"code\">const iterable = {\n\t[Symbol.iterator]() {\n    \tlet i=3\n        return {\n        \tnext() {\n            \treturn i==0 ? {done: true} : {value: i--, done:false}\n            }\n        }\n    }\n}\n\nconst iterator = iterable[Symbol.iterator]()\niterator.next()\n\nfor (const a of iterable) {\n\tconsole.log(a)\n}\n\n3\n2\n1</code>\n        </deckgo-highlight-code>\n<br />\n<p>iterable 안에는 Symbol.iterator가 구현되어 있기 때문에, for (const a of iterable) 구문을 사용할 수 있게된다.</p>\n<p>그리고 한가지 더 구현되야 하는데, iterable[Symbol.iterator]() 가 반환하는 객체에는 next메소드 이외에 자기 자신을 반환하는 Symbol.iterator 프로퍼티가 있어야한다.</p>\n<p>즉, iterable의 Symbol.iterator 프로퍼티 또한 iteration protocol을 따르는 객체를 반환하기 때문에 Symbol.iterator가 있어야 한다.</p>\n<p>따라서 위의 코드를 다시 작성해보자면 다음과 같다.</p>\n<br />\n<deckgo-highlight-code  terminal=\"carbon\"  >\n          <code slot=\"code\">const iterable = {\n\t[Symbol.iterator]() {\n    \tlet i=3\n        return {\n        \tnext() {\n            \treturn i==0 ? {done: true} : {value: i--, done:false}\n            },\n\n            [Symbol.iterator]() { return this }\n        }\n    }\n}\n\nconst iterator = iterable[Symbol.iterator]()\niterator.next()\n\nfor (const a of iterable) {\n\tconsole.log(a)\n}\n\nconsole.log(iterator === iterator[Symbol.iterator]())\n\n3\n2\n1\ntrue</code>\n        </deckgo-highlight-code>\n<br />","frontmatter":{"title":"[ES6+] iteration protocol","summary":"ES6에서 달라진 리스트 순회에 대해 알아보자.","date":"2021.09.20.","categories":["JavaScript"],"thumbnail":{"childImageSharp":{"gatsbyImageData":{"layout":"constrained","placeholder":{"fallback":"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAALCAIAAADwazoUAAAACXBIWXMAAAsTAAALEwEAmpwYAAABtklEQVQoz2P4cCsAF3p/M+D7g8B/z4I+3Ql8dyPg6/2A/8+D/z0L/nIPJPXhVgADHp3f7gee3OG5YIrT43N+Px8FXj3kM73bcc4Ex3unfL/eC3x/E7fmN9f9/78I7mywk5bTuXbE59YxHzs7I3VNPUUlXVdn40fn/D7fwa35LVhzf6u9qrruo3O+s/ud5BR0T2z3PLXTc/YEx3c3Aj7eJqS5r8VeWVX3/hnftfNc5RR0aktsHp/z/f8m5NMd3M5+fzPg9TWw5mZ7NXW9K4e8P9wKyEy2lJXX1dXVb6+1e4vH5s93Ar7cDfz3DGSzmobexf3e/18Ef3sUuGmxa1SouYy8zpROh9+Pg7Bo/ng74Pklv5PbPf+/D+lvsVdV07t+xOfCPu8dK9z+fw59dyfAytIwKdbi671AdM3vbgT8ehzU1QAKp7pSGztbI1sbo7fX/bNAbtapKLAuyraWU9DtqLf7hWnz+5sgB18/4pObamlmZujnbbpzpfuvR4F3TvhUFlpbWxlZWxnWltg8u4gjqiDJ49v9wFdX/T/cCvj+EBSwX+8F/ngY+Oaa/5vr/t8fBn6+CwptAJdrjPYzZvDjAAAAAElFTkSuQmCC"},"images":{"fallback":{"src":"/static/e9a85b5a3a7f83d86a85a4c348938bd5/ddad7/js.png","srcSet":"/static/e9a85b5a3a7f83d86a85a4c348938bd5/602a4/js.png 450w,\n/static/e9a85b5a3a7f83d86a85a4c348938bd5/4c0f7/js.png 900w,\n/static/e9a85b5a3a7f83d86a85a4c348938bd5/ddad7/js.png 1800w","sizes":"(min-width: 1800px) 1800px, 100vw"},"sources":[{"srcSet":"/static/e9a85b5a3a7f83d86a85a4c348938bd5/06689/js.webp 450w,\n/static/e9a85b5a3a7f83d86a85a4c348938bd5/eca74/js.webp 900w,\n/static/e9a85b5a3a7f83d86a85a4c348938bd5/23de5/js.webp 1800w","type":"image/webp","sizes":"(min-width: 1800px) 1800px, 100vw"}]},"width":1800,"height":1012}}}}}}]}},"pageContext":{"slug":"/iteration_protocol/"}},
    "staticQueryHashes": []}