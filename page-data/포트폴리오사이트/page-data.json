{
    "componentChunkName": "component---src-templates-post-tsx",
    "path": "/포트폴리오사이트/",
    "result": {"data":{"allMarkdownRemark":{"edges":[{"node":{"html":"<h3><a href=\"https://github.com/seongjunme/my-blog\" target=\"_blank\" rel=\"nofollow\">프로젝트 repository 바로가기</a></h3>\n<hr>\n<h2>🖥 프로젝트 소개</h2>\n<p>평소에 구현해보고 싶었던 Full Page의 기능을 중점으로</p>\n<p>포트폴리오와 작성한 블로그들을 정리하기 위한 사이트</p>\n<h2>📚 기술 스택</h2>\n<ul>\n<li>\n<p>React (hooks)</p>\n</li>\n<li>\n<p>TypeScript</p>\n</li>\n<li>\n<p>Emotion</p>\n</li>\n<li>\n<p>Gatsby</p>\n</li>\n<li>\n<p>Graphql</p>\n</li>\n</ul>\n<h2>🛠 주요 기능</h2>\n<ul>\n<li>Gatsby를 이용한 블로그</li>\n<li>Full Page 사이트</li>\n<li>무한 스크롤 기능</li>\n<li>반응형 UI 구현</li>\n</ul>\n<h2>👍 기술 특장점</h2>\n<p>1️⃣ Graphql을 이용한 Markdown 데이터 요청 <br>\n2️⃣ Gatsby의 slug 기능을 이용하여 해당 Markdown 게시글과 연동 <br>\n3️⃣ Full Page 구현 <br>\n4️⃣ 무한 스크롤 구현 <br>\n5️⃣ Fullpage 태블릿 &#x26; 모바일 환경 호환 <br></p>\n<h3>1️⃣ Graphql을 이용한 Markdown 데이터 요청</h3>\n<p>Gatsby에서 제공해주는 Graphql을 이용하여 Markdown 데이터 소스를 얻고, 이를 html로 변환할 수 있다.\n이를 위해서는 먼저 두 가지 플러그인이 필요하다.</p>\n<ul>\n<li>gatsby-source-filesystem</li>\n<li>gatsby-transformer-remark</li>\n</ul>\n<p>플러그인을 설치한 후 gatsby-config에 다음과 같이 작성해준다.</p>\n<deckgo-highlight-code language=\"js\" terminal=\"carbon\"  >\n          <code slot=\"code\">// gatsby-config.js\nmodule.exports = {\n  plugins: [\n    {\n      resolve: `gatsby-source-filesystem`,\n      options: {\n        name: `contents`,\n        path: `${__dirname}/contents`,\n      },\n    },\n    {\n      resolve: `gatsby-transformer-remark`,\n      options: {\n        plugins: [...],\n      },\n    }\n  ],\n};\n</code>\n        </deckgo-highlight-code>\n<h4><strong>gatsby-source-filesystem</strong></h4>\n<p>로컬 파일 시스템의 파일을 File 노드로 생성하여 graphql을 통해 데이터를 얻을 수 있다. <br />\n단, 마크다운을 path에 지정한 경로에 저장해야한다.</p>\n<h4>gatsby-transformer-remark</h4>\n<p>마크다운 파일을 파싱하여 MarkdownRemark 노드로 생성한다.\n생성된 노드는 graphql을 통해 데이터를 얻을 수 있다.</p>\n<br />\n<deckgo-highlight-code  terminal=\"carbon\"  >\n          <code slot=\"code\">query getMarkdownData {\n  allMarkdownRemark {\n    edges {\n      node {\n        html\n        id\n        frontmatter {\n          title,\n          summary,\n          ...\n        }\n      }\n    }\n  }\n}</code>\n        </deckgo-highlight-code>\n<br />\n<h3>2️⃣ Gatsby의 slug 기능을 이용하여 해당 Markdown 게시글과 연동</h3>\n<h4>slug 생성</h4>\n<p>마크다운 데이터에 slug 필드를 추가하여 해당 게시물에 접근하기 위한 url을 생성한다.</p>\n<p>해당 기능을 사용하기 위해선 onCreateNode라는 gatsby에서 제공하는 API를 사용한다.</p>\n<br />\n<deckgo-highlight-code language=\"js\" terminal=\"carbon\"  >\n          <code slot=\"code\">// gatsby-node.js\nexports.onCreateNode = ({ node, getNode, actions }) =&gt; {\n  const { createNodeField } = actions;\n\n  if (node.internal.type === `MarkdownRemark`) {\n    const slug = createFilePath({ node, getNode });\n\n    createNodeField({ node, name: &#39;slug&#39;, value: slug });\n  }\n};</code>\n        </deckgo-highlight-code>\n<br />\n마크다운 데이터에 한해서 slug 필드를 추가한다.\n그리고 slug데이터는 경로와 파일명을 조합해 생성된다.\n<p>ex) contents/ShallWeSound.md -> domain/ShallWeSound</p>\n<h4>slug를 이용해 페이지 생성</h4>\n<p>마크다운 데이터를 이용해 slug를 생성해주었으니, 이제는 이 slug를 이용해 접근할 페이지를 생성한다.\n페이지 생성은 gatsby의 createPages API를 이용한다.</p>\n<br />\n<deckgo-highlight-code language=\"js\" terminal=\"carbon\"  >\n          <code slot=\"code\">// gatsby-node.js\nexports.createPages = async ({ actions, graphql, reporter }) =&gt; {\n  const { createPage } = actions;\n\n  const queryAllMarkdownData = await graphql(\n    `\n      {\n        allMarkdownRemark {\n          edges {\n            node {\n              fields {\n                slug\n              }\n            }\n          }\n        }\n      }\n    `,\n  );\n\n  if (queryAllMarkdownData.errors) {\n    reporter.panicOnBuild(`Query Error`);\n    return;\n  }\n\n  const PostTemplateComponent = path.resolve(__dirname, &#39;src/templates/post.tsx&#39;);\n\n  const generatePostPage = ({\n    node: {\n      fields: { slug },\n    },\n  }) =&gt; {\n    const pageOptions = {\n      path: slug,\n      component: PostTemplateComponent,\n      context: { slug },\n    };\n\n    createPage(pageOptions);\n  };\n\n  queryAllMarkdownData.data.allMarkdownRemark.edges.forEach(generatePostPage);\n};</code>\n        </deckgo-highlight-code>\n<br />\n<p>template 폴더에 post.tsx로 게시글 페이지의 템플릿을 정의한다.\n그리고 그 템플릿 컴포넌트를 불러온다.</p>\n<p>다음으로 pageOtions을 정의하고, 실제로 페이지를 생성해줄 generatePostPage 함수를 정의한다.\n여기서 path는 페이지의 경로를 나타내고, component는 게시글을 렌더링할 컴포넌트를 의미한다.\n마지막으로 context는 바로 앞서 정의한 component에 props로 넘겨줄 수 있는 값이다.\n이 slug를 통해 해당 컴포넌트에서 맞는 마크다운 문서를 찾아 불러올 수 있다.</p>\n<p>그리고 graphql을 통해 불러온 queryAllMarkdownData 값에서 markdown 데이터가 들어있는 edges를 반복하여 페이지 생성 함수를 실행해 준다.</p>\n<h3>3️⃣ Full Page 구현</h3>\n<h4>useFullPage라는 커스텀 훅을 생성 - index.tsx</h4>\n<ul>\n<li>반환 값으로는\n<ul>\n<li>최상단을 지정하기 위한 outerRef</li>\n<li>현재 부분(페이지)를 저장하기 위한 currentPageName</li>\n<li>full page 상단의 navBar를 클릭했을 때의 이벤트 핸들러 onClickNavBar</li>\n</ul>\n</li>\n</ul>\n<deckgo-highlight-code language=\"jsx\" terminal=\"carbon\"  >\n          <code slot=\"code\">// index.tsx\nconst Index: React.FC = () =&gt; {\n  const [outerRef, currentPageName, onClickNavBar] = useFullPage({ maxPageCount: 3 });\n\n  return (\n    &lt;Background ref={outerRef} className=&quot;outer&quot;&gt;\n      &lt;NavBar currentPageName={currentPageName} onClickNavBar={onClickNavBar} /&gt;\n      &lt;About /&gt;\n      &lt;PostList /&gt;\n      &lt;PostList /&gt;\n      &lt;Contact /&gt;\n    &lt;/Background&gt;\n  );\n};</code>\n        </deckgo-highlight-code>\n<h4>useFullPage.tsx</h4>\n<ul>\n<li>인자로 페이지(파트)의 최대 수를 받는다.\n<ul>\n<li>페이지 수는 0부터 시작</li>\n</ul>\n</li>\n<li>현재 페이지 번호를 useRef로 관리한다.\n<ul>\n<li>번호를 state로 관리하면 스크롤을 이동할 때, state의 최신값을 사용하기가 어려워진다.</li>\n</ul>\n</li>\n</ul>\n<deckgo-highlight-code language=\"js\" terminal=\"carbon\"  >\n          <code slot=\"code\">// useFullPage.tsx\nconst PAGE_NAMES = [&#39;About&#39;, &#39;Project&#39;, &#39;Blog&#39;, &#39;Contact&#39;];\n\nconst useFullPage = ({ maxPageCount }: { maxPageCount: number }) =&gt; {\n  const outerRef = useRef&lt;any&gt;();\n  const currentPage = useRef(0);\n  const [currentPageName, setCurrentPageName] = useState(PAGE_NAMES[currentPage.current]);\n\n  ...\n}</code>\n        </deckgo-highlight-code>\n<h4>wheel 동작에 따라 currentPage가 가리키는 부분으로 스크롤을 이동시킨다.</h4>\n<ul>\n<li>이동 시키는 기준은 현재 화면 크기(window.innerHeight)와 currentPage가 가리키는 값이다.</li>\n<li>현재 화면 크기가 720px이고 현재 페이지 번호가 0일 때 top은 0이되고, 페이지 번호가 1이면 top은 720px이 된다.</li>\n<li>즉, 0~720px은 페이지 0이 차지하고, 720px ~ 1440px 은 페이지 1이 차지한다는 뜻이다.</li>\n</ul>\n<deckgo-highlight-code language=\"jsx\" terminal=\"carbon\"  >\n          <code slot=\"code\">// useFullPage.tsx\nconst useFullPage = ({ maxPageCount }: { maxPageCount: number }) =&gt; {\n  ...\n\n  const scrollToCurrentPage = () =&gt; {\n    outerRef.current.scrollTo({\n      top: window.innerHeight * currentPage.current,\n      left: 0,\n      behavior: &#39;smooth&#39;,\n    });\n  };\n\n  const scrollDown = () =&gt; {\n    currentPage.current += 1;\n    scrollToCurrentPage();\n    setCurrentPageName(PAGE_NAMES[currentPage.current]);\n  };\n\n  const scrollUp = () =&gt; {\n    currentPage.current -= 1;\n    scrollToCurrentPage();\n    setCurrentPageName(PAGE_NAMES[currentPage.current]);\n  };\n}</code>\n        </deckgo-highlight-code>\n<h4>outerRef에 이벤트 등록</h4>\n<ul>\n<li>deltaY 값을 확인해, wheel 이벤트가 위인지, 아래인지 구분하여 동작시킨다.</li>\n<li>debounce를 적용하여 한번에 wheel 이벤트 핸들러가 연속으로 수행되지 않도록 한다.\n<ul>\n<li>마우스 휠의 경우 굉장히 민감하기 때문에 조금만 움직여도 수십개의 이벤트가 발생한다.</li>\n<li>따라서 스크롤 한번으로 첫 페이지에서 마지막 페이지 까지 내려가는 현상이 발생했고, 이를 debounce를 적용함으로써 해결하였다.</li>\n</ul>\n</li>\n</ul>\n<deckgo-highlight-code language=\"jsx\" terminal=\"carbon\"  >\n          <code slot=\"code\">// useFullPage.tsx\nconst useFullPage = ({ maxPageCount }: { maxPageCount: number }) =&gt; {\n  ...\n\n  useEffect(() =&gt; {\n    const wheelHandler = debounce((e: WheelEvent) =&gt; {\n      e.preventDefault();\n\n      const { deltaY } = e;\n\n      if (deltaY &gt; 0 &amp;&amp; currentPage.current &lt; maxPageCount) {\n        scrollDown();\n      } else if (deltaY &lt; 0 &amp;&amp; currentPage.current &gt; 0) {\n        scrollUp();\n      }\n    }, 50);\n\n    outerRef.current?.addEventListener(&#39;wheel&#39;, wheelHandler);\n\n    return () =&gt; {\n      outerRef.current?.removeEventListener(&#39;wheel&#39;, wheelHandler);\n    };\n  }, []);\n}\n</code>\n        </deckgo-highlight-code>\n<br />\n<deckgo-highlight-code language=\"js\" terminal=\"carbon\"  >\n          <code slot=\"code\">// debounce.ts\nconst debounce = (callback: (...arg: any) =&gt; void, delay: number) =&gt; {\n  let timer: NodeJS.Timeout;\n\n  return (...arg: any) =&gt; {\n    clearTimeout(timer);\n    timer = setTimeout(() =&gt; callback(...arg), delay);\n  };\n};\n\nexport default debounce;</code>\n        </deckgo-highlight-code>\n<h4>마지막으로 브라우저 창의 크기를 변경할 시, window.innerHeight를 다시 계산하여 해당 값에 맞게 스크롤을 이동시켜야 한다.</h4>\n<ul>\n<li>resize 이벤트 발생 시, 현재 페이지를 기준으로 스크롤을 이동시켜주는 함수를 실행시킨다.</li>\n</ul>\n<deckgo-highlight-code language=\"js\" terminal=\"carbon\"  >\n          <code slot=\"code\">// useFullPage.tsx\nuseEffect(() =&gt; {\n  window.addEventListener(&#39;resize&#39;, scrollToCurrentPage);\n\n  return () =&gt; {\n    window.removeEventListener(&#39;resize&#39;, scrollToCurrentPage);\n  };\n});</code>\n        </deckgo-highlight-code>\n<br />\n<h3>4️⃣ 무한 스크롤 구현</h3>\n<h4>useInfiniteScroll 라는 커스텀 훅을 생성하고 사용</h4>\n<ul>\n<li>posts 배열과, 카테고리에 따른 필터링을 위해 selectedCategory를 인자로 넘겨준다.</li>\n<li>반환 값으로는 observe할 Ref와 posts의 부분 배열인 postsByPage 배열이 반환된다.</li>\n</ul>\n<deckgo-highlight-code language=\"jsx\" terminal=\"carbon\"  >\n          <code slot=\"code\">const BlogList: React.FC&lt;Props&gt; = ({ posts, selectedCategory }) =&gt; {\n  const { targetRef, postsByPage } = useInfiniteScroll({ posts, selectedCategory });\n\n  return (\n    &lt;Wrapper ref={targetRef}&gt;\n      {postsByPage.map(\n        ({\n          node: {\n            id,\n            fields: { slug },\n            frontmatter,\n          },\n        }) =&gt; (\n          &lt;PostItem key={id} link={slug} {...frontmatter} /&gt;\n        ),\n      )}\n    &lt;/Wrapper&gt;\n  );\n};</code>\n        </deckgo-highlight-code>\n<br />\n<h4>useInfiniteScroll 구현</h4>\n<ul>\n<li>page 상태에 따라 렌더링할 post의 개수를 정한다.\n<ul>\n<li>page 값이 1이면 page(1) * POST_COUNT_BY_PAGE(9) = 9 개의 post가 반환된다.</li>\n</ul>\n</li>\n<li>IntersectionOberserver를 활용하여 observe 이벤트 발생 시 page를 1증가 시킨다.\n<ul>\n<li>page가 증가함에 따라 최대 9개의 새로운 포스트가 추가로 반환된다.</li>\n</ul>\n</li>\n<li>observer가 targetRef의 children의 마지막 요소를 관찰하도록 한다.\n<ul>\n<li>스크롤을 끝까지 내려서 마지막 요소가 관찰되면 등록한 이벤트 리스너를 수행한다.</li>\n</ul>\n</li>\n<li>observer를 매번 disconnect하고 새롭게 observe등록을 하는 이유는 마지막 post까지 렌더링했다면 더 이상 observe할 필요가 없기 때문에 매번 모든 post가 출력됐다면 observe를 등록하지 않도록 하기 위함이다.</li>\n<li>마지막으로 selectedCategory가 변경되면 page를 1로 초기화 해주는 작업을 한다.\n<ul>\n<li>초기화 하지 않으면 카테고리가 바뀌어도 page가 그대로 유지 되는 현상이 발생한다.</li>\n</ul>\n</li>\n</ul>\n<deckgo-highlight-code language=\"jsx\" terminal=\"carbon\"  >\n          <code slot=\"code\">// useInfiniteScroll.tsx\nimport { MutableRefObject, useState, useRef, useEffect, useMemo } from &#39;react&#39;;\nimport { PostListType } from &#39;types/post.types&#39;;\n\nconst POST_COUNT_BY_PAGE = 9;\n\nconst useInfiniteScroll = ({ posts, selectedCategory }: { posts: PostListType[], selectedCategory: string }) =&gt; {\n  const [page, setPage] = useState(1);\n  const targetRef: MutableRefObject&lt;HTMLDivElement | null&gt; = useRef &lt; HTMLDivElement &gt; null;\n\n  const filteredPosts = useMemo(\n    () =&gt;\n      posts.filter(\n        ({\n          node: {\n            frontmatter: { categories },\n          },\n        }) =&gt; selectedCategory === &#39;All&#39; || categories.includes(selectedCategory),\n      ),\n    [selectedCategory],\n  );\n\n  const observer = new IntersectionObserver(\n    (entries, observer) =&gt; {\n      if (!entries[0].isIntersecting) return;\n\n      setPage(prev =&gt; prev + 1);\n      observer.disconnect();\n    },\n    {\n      threshold: 1.0,\n    },\n  );\n\n  useEffect(() =&gt; setPage(1), [selectedCategory]);\n\n  useEffect(() =&gt; {\n    if (\n      !targetRef.current ||\n      page * POST_COUNT_BY_PAGE &gt;= filteredPosts.length ||\n      targetRef.current.children.length &lt;= 0\n    )\n      return;\n\n    observer.observe(targetRef.current.children[targetRef.current.children.length - 1]);\n  }, [page, selectedCategory]);\n\n  return {\n    targetRef,\n    postsByPage: filteredPosts.slice(0, page * POST_COUNT_BY_PAGE),\n  };\n};\n\nexport default useInfiniteScroll;</code>\n        </deckgo-highlight-code>\n<h3>5️⃣ Fullpage 태블릿 &#x26; 모바일 환경 호환</h3>\n<h4>화면 높이 지정 - 100vh</h4>\n<ul>\n<li>모바일 환경에서의 100vh는 브라우저 상단의 url 영역과 하단의 네비게이션 영역을 포함한다.</li>\n<li>따라서 높이를 화면 가득 채우려고 100vh를 사용한다면 실제 화면보다 높이가 크게 잡히는 문제가 발생한다.</li>\n<li>따라서 window.innerHeight를 사용하여 실제 화면 높이를 가져온 후 설정해준다.</li>\n</ul>\n<deckgo-highlight-code language=\"jsx\" terminal=\"carbon\"  >\n          <code slot=\"code\">useEffect(() =&gt; {\n  const setScreenSize = () =&gt; {\n    const vh = window.innerHeight * 0.01;\n    document.documentElement.style.setProperty(&#39;--vh&#39;, `${vh}px`);\n  };\n  setScreenSize();\n\n  window.addEventListener(&#39;resize&#39;, setScreenSize);\n\n  return () =&gt; {\n    window.removeEventListener(&#39;resize&#39;, setScreenSize);\n  };\n}, []);</code>\n        </deckgo-highlight-code>\n<ul>\n<li>\n<p>resize 이벤트 발생 시에 화면 크기가 변경되는 것을 고려하여 이벤트를 등록해준다.</p>\n</li>\n<li>\n<p>–vh변수에 계산한 innerHeight 값을 저장한 뒤 다음과 같이 사용한다.</p>\n</li>\n</ul>\n<deckgo-highlight-code language=\"css\" terminal=\"carbon\"  >\n          <code slot=\"code\">body {\n  height: calc(var(--vh, 1vh) * 100);\n}</code>\n        </deckgo-highlight-code>\n<ul>\n<li>\n<p>–vh가 존재하면 그 값을, 아니면 1vh를 사용한다.</p>\n</li>\n<li>\n<p>모바일의 경우 가로, 세로 전환을 할 수 있다.</p>\n</li>\n<li>\n<p>가로, 세로 전환 시 resize 이벤트가 2번 발생하는 경우가 발생했다.</p>\n</li>\n<li>\n<p>이 문제 때문에 화면 높이가 제대로 잡히지 않는 현상이 발생했고 이를 해결하기 위해 debounce를 적용하여 마지막 이벤트만 수행하도록 했다.</p>\n</li>\n</ul>\n<deckgo-highlight-code language=\"jsx\" terminal=\"carbon\"  >\n          <code slot=\"code\">useEffect(() =&gt; {\n  const setScreenSize = debounce(() =&gt; {\n    const vh = window.innerHeight * 0.01;\n    document.documentElement.style.setProperty(&#39;--vh&#39;, `${vh}px`);\n  }, 50);\n\n  setScreenSize();\n\n  window.addEventListener(&#39;resize&#39;, setScreenSize);\n\n  return () =&gt; {\n    window.removeEventListener(&#39;resize&#39;, setScreenSize);\n  };\n}, []);</code>\n        </deckgo-highlight-code>\n<h4>터치 이벤트 적용</h4>\n<ul>\n<li>현재 Full Page의 경우 wheel 이벤트만 등록되어 있다.</li>\n<li>모바일 환경에서는 wheel보다는 touch를 사용하므로 그에 따른 대안이 필요하다.</li>\n<li>touch의 방향을 알기 위해 touchstart의 y좌표와 touchend의 y좌표를 비교한다.</li>\n<li>touchstart의 y좌표가 더 크다면 아래에서 위로 드래그한 것이므로 scollDown()을 실행한다.</li>\n<li>반다로 touchend의 y좌표가 더 크다면 위에서 아래로 드래그한 것이므로 scollUp()을 실행한다.</li>\n</ul>\n<deckgo-highlight-code language=\"jsx\" terminal=\"carbon\"  >\n          <code slot=\"code\">const touchStartY = useRef(0);\nconst touchEndY = useRef(0);\n\nuseEffect(() =&gt; {\n  const touchStartHandler = debounce((e: TouchEvent) =&gt; {\n    e.preventDefault();\n\n    touchStartY.current = e.changedTouches[0].clientY;\n  }, 50);\n\n  const touchEndHandler = debounce((e: TouchEvent) =&gt; {\n    e.preventDefault();\n\n    touchEndY.current = e.changedTouches[0].clientY;\n\n    if (touchStartY.current &lt; touchEndY.current &amp;&amp; currentPage.current &gt; 0) {\n      scrollUp();\n    } else if (touchStartY.current &gt; touchEndY.current &amp;&amp; currentPage.current &lt; maxPageCount) {\n      scrollDown();\n    }\n  }, 50);\n\n  outerRef.current?.addEventListener(&#39;touchstart&#39;, touchStartHandler);\n  outerRef.current?.addEventListener(&#39;touchend&#39;, touchEndHandler);\n\n  return () =&gt; {\n    outerRef.current?.removeEventListener(&#39;touchstart&#39;, touchStartHandler);\n    outerRef.current?.removeEventListener(&#39;touchend&#39;, touchEndHandler);\n  };\n}, []);</code>\n        </deckgo-highlight-code>\n<h4>scroll smooth-behavior</h4>\n<ul>\n<li>\n<p>마지막으로 웹 브라우저에서는 다음과 같은 코드가 잘 동작한다.</p>\n<deckgo-highlight-code language=\"js\" terminal=\"carbon\"  >\n          <code slot=\"code\">outerRef.current?.scrollTo({\n  top: window.innerHeight * currentPage.current,\n  left: 0,\n  behavior: &#39;smooth&#39;,\n});</code>\n        </deckgo-highlight-code>\n</li>\n<li>\n<p>하지만 모바일 브라우저에 따라서는 smooth 동작이 수행되지 않는 경우가 있다.</p>\n</li>\n<li>\n<p>따라서 다음과 같은 패키지를 설치해준다.</p>\n</li>\n</ul>\n<deckgo-highlight-code  terminal=\"carbon\"  >\n          <code slot=\"code\">npm install smoothscroll-polyfill --save</code>\n        </deckgo-highlight-code>\n<ul>\n<li>그리고 다음과 같이 사용한다.</li>\n</ul>\n<deckgo-highlight-code language=\"js\" terminal=\"carbon\"  >\n          <code slot=\"code\">import smoothscroll from &#39;smoothscroll-polyfill&#39;;\n\nsmoothscroll.polyfill();</code>\n        </deckgo-highlight-code>","frontmatter":{"title":"Gatsby로 만든 포트폴리오 사이트","summary":"Full Page의 기능을 중점으로 포트폴리오와 작성한 블로그들을 정리하기 위한 사이트","date":"2022.03.08.","categories":["React","Gatsby"],"thumbnail":{"childImageSharp":{"gatsbyImageData":{"layout":"constrained","placeholder":{"fallback":"data:image/jpeg;base64,/9j/2wBDAAEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQH/2wBDAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQH/wgARCAALABQDASIAAhEBAxEB/8QAGAAAAgMAAAAAAAAAAAAAAAAAAAgDBgn/xAAWAQEBAQAAAAAAAAAAAAAAAAAFAwT/2gAMAwEAAhADEAAAAc6oKmrcU3XFlN5P/8QAGhAAAgMBAQAAAAAAAAAAAAAAAgUDBAYBAP/aAAgBAQABBQLYrKFmTXlnF6V4pi11hsIyphMw52aUff/EACERAAICAQMFAQAAAAAAAAAAAAECAxEEABQhEiIxQXGh/9oACAEDAQE/AcmsVZoAkbbuCNWkYFnjQ9EhWPmg1qvfV1YHm9LgQqoG4yuAPUR/Tyfuv//EACARAAICAQMFAAAAAAAAAAAAAAECAxEhAAQxEyMkYdH/2gAIAQIBAT8B2ymboyGR/GlcqooKzZQFsXQDNi8nJ4rR3zknsQc+/mv/xAAlEAACAgEDBAEFAAAAAAAAAAACAwEEBRESEwAUI2EhBiJBUXH/2gAIAQEABj8Cxz2ZBIHespS0AC2b/PaFR2WZi1yIt9uTHGyqVfHHT2hXCuqB5CxGIxotyNj6dfmsS7JHVNCX2rSu6rzqW2CktxMVsXE+Ldys2Awqebp2K1EHYrGoaNlrGWXvqVhrMfYYxL5a3xwmW8ky2Eiw9GEfQCwRnfxkc6QJsJcsUBMYOjDmFiIakU/bGk9DIlIz8fMTp6/HqZj+TP76gRayIgF6RBlER4w99f/EABwQAQADAAIDAAAAAAAAAAAAAAEAESExQVGBsf/aAAgBAQABPyF9EvkD10q+LcKPcKOwJAsyC3EdJICleLmEgLLfLHJZHd9VCwncOpPb8Xzhwo0A6OF1AArfXBgT/9oADAMBAAIAAwAAABBI3//EABcRAQEBAQAAAAAAAAAAAAAAAAERITH/2gAIAQMBAT8Q2H2uKpLtlETUsJ4DhAIYQMoF6guf/8QAGREBAQADAQAAAAAAAAAAAAAAAREAITFB/9oACAECAQE/EIHVHEydTHGtCkBi7Lk19ZUu2VlSunP/xAAXEAEBAQEAAAAAAAAAAAAAAAABEQAh/9oACAEBAAE/EJAdo1YD7LaLC6fiMGHram7agCSkfCRDxk0fAD+AgKCz4o1L7lyERUPRIg6BW4cYjK8CoBBIAP/Z"},"images":{"fallback":{"src":"/static/4668e12bd54d5b9fec0afef8d6a1780b/2c6c2/gatsby.jpg","srcSet":"/static/4668e12bd54d5b9fec0afef8d6a1780b/7394a/gatsby.jpg 78w,\n/static/4668e12bd54d5b9fec0afef8d6a1780b/7ebbd/gatsby.jpg 155w,\n/static/4668e12bd54d5b9fec0afef8d6a1780b/2c6c2/gatsby.jpg 310w","sizes":"(min-width: 310px) 310px, 100vw"},"sources":[{"srcSet":"/static/4668e12bd54d5b9fec0afef8d6a1780b/42371/gatsby.webp 78w,\n/static/4668e12bd54d5b9fec0afef8d6a1780b/a5c7f/gatsby.webp 155w,\n/static/4668e12bd54d5b9fec0afef8d6a1780b/ea16f/gatsby.webp 310w","type":"image/webp","sizes":"(min-width: 310px) 310px, 100vw"}]},"width":310,"height":163}}}}}}]}},"pageContext":{"slug":"/포트폴리오사이트/"}},
    "staticQueryHashes": []}