{
    "componentChunkName": "component---src-templates-post-tsx",
    "path": "/[js]_this/",
    "result": {"data":{"allMarkdownRemark":{"edges":[{"node":{"html":"<h1>this 키워드가 필요한 이유</h1>\n<p>JS에서 객체는 상태를 나타내는 프로퍼티와 동작을 나타내는 메서드를 하나의 논리적인 단위로 묶은 복합적 자료구조다.</p>\n<p>동작을 나타내는 메서드는 자신이 속한 객체의 상태, 즉 프로퍼티를 참조하고 변경할 수 있어야 한다.\n이때 메서드가 자신이 속한 객체의 프로퍼티를 참조하려면 먼저 자신이 속한 객체를 가리키는 식별자를 참조할 수 있어야 한다.</p>\n<br />\n<deckgo-highlight-code  terminal=\"carbon\"  >\n          <code slot=\"code\">const circle = {\n\tradius: 5,\n    getDiameter() {\n    \treturn 2*circle.radius\n    }\n}</code>\n        </deckgo-highlight-code>\n<br />\ngetDiameter 메서드 내에서 메서드 자신이 속한 객체를 가리키는 식별자 circle를 참조하고 있다.\ngetDiameter 메서드가 호출되는 시점은 이미 circle 객체가 생성되어 식별자에 할당되었기 때문에 참조가 가능하다.\n<p>하지만 자기 자신이 속한 객체를 재귀적으로 참조하는 방식은 일반적이지 않으며 바람직하지도 않다.</p>\n<p>또, 생성자 함수 방식으로 인스턴스를 생성하는 경우를 생각해보자.</p>\n<br />\n<deckgo-highlight-code  terminal=\"carbon\"  >\n          <code slot=\"code\">function Circle(radius) {\n\t???.radius = radius\n}</code>\n        </deckgo-highlight-code>\n<br />\n<p>생성자 함수 내부에서는 프로퍼티 또는 메서드를 추가하기 위해 자신이 생성할 인스턴스를 참조할 수 있어야 한다. 하지만 생성자 함수에 의한 객체 생성 방식은 먼저 생성자 함수를 정의한 이후 new 연산자와 함께 생성자 함수를 호출하는 단계가 추가로 필요하다. 다시 말해, 생성자 함수로 인스턴스를 생성하려면 먼저 생성자 함수가 존재해야 한다. <br /></p>\n<p>생성자 함수를 정의하는 시점에는 아직 인스턴스를 생성하기 이전이므로 생성자 함수가 생성할 인스턴스를 가리키는 식별자를 알 수 없다. 따라서 자신이 속한 객체 또는 자신이 생성할 인스턴스를 가리키는 특수한 식별자가 필요하다. 이를 위해 JS에선 this 키워드를 제공한다. <br /></p>\n<p><strong>즉, this는 자신이 속한 객체 또는 자신이 생성할 인스턴스를 가리키는 자기 참조 변수다.</strong></p>\n<p>this는 자바스크립트 엔진에 의해 암묵적으로 생성되며, 코드 어디서든 참조할 수 있다.\n함수를 호출하면 arguments 객체와 this가 암묵적으로 함수 내부에 전달된다.\narguments를 지역 변수처럼 사용할 수 있는 것 처럼 this도 지역 변수처럼 사용할 수 있다.</p>\n<p><strong>단, this가 가리키는 값, 즉 this 바인딩은 함수 호출 방식에 의해 동적으로 결정된다.</strong></p>\n<blockquote>\n<p>바인딩이란 식별자와 값을 연결하는 과정을 의미한다. 예를 들어 변수 선언은 변수 이름(식별자)과 확보된 메모리 공간의 주소를 바인딩하는 것이다.</p>\n</blockquote>\n<p>이제 위의 예시 코드를 this를 이용하여 다시 작성해보자.</p>\n<br />\n<deckgo-highlight-code  terminal=\"carbon\"  >\n          <code slot=\"code\">const circle = {\n\tradius: 5,\n    getDiameter() {\n    \treturn 2*this.radius\n    }\n}</code>\n        </deckgo-highlight-code>\n<br />\n<p><strong>객체 리터럴의 메서드 내부에서의 this는 메서드를 호출한 객체, 즉 circle를 가리킨다.</strong></p>\n<br />\n<deckgo-highlight-code  terminal=\"carbon\"  >\n          <code slot=\"code\">function Circle(radius) {\n\tthis.radius = radius\n}</code>\n        </deckgo-highlight-code>\n<br />\n<p><strong>생성자 함수 내부의 this는 생성자 함수가 생성할 인스턴스를 가리킨다.</strong></p>\n<h1>함수 호출 방식과 this 바인딩</h1>\n<h2>일반 함수 호출</h2>\n<p>일반 함수 호출은 기본적으로 this에 전역 객체(window)가 바인딩 된다.\n<br /></p>\n<deckgo-highlight-code  terminal=\"carbon\"  >\n          <code slot=\"code\">function foo() {\n\tconsole.log(this) // window\n\n    function bar() {\n    \tconsole.log(this) //window\n    }\n}</code>\n        </deckgo-highlight-code>\n<br />\n<p>콜백 함수로 일반 함수가 호출된다면 마찬가지로 window를 가리킨다.\n<br /></p>\n<deckgo-highlight-code  terminal=\"carbon\"  >\n          <code slot=\"code\">const value = 1\n\nconst obj = {\n\tvalue: 100,\n    foo() {\n    \tsetTimeout(function() {\n        \tconsole.log(this.value) // 1\n        }, 1000)\n    }\n}</code>\n        </deckgo-highlight-code>\n<br />\n<p>하지만 화살표 함수를 사용한다면 함수 내부의 this는 상위 스코프의 this를 가리킨다.\n<br /></p>\n<deckgo-highlight-code  terminal=\"carbon\"  >\n          <code slot=\"code\">const value = 1\n\nconst obj = {\n\tvalue: 100,\n    foo() {\n    \tsetTimeout(() =&gt; {\n        \tconsole.log(this.value) // 100\n        }, 1000)\n    }\n}</code>\n        </deckgo-highlight-code>\n<br />\n<h2>메서드 호출</h2>\n<p>메서드 내부의 this에는 메서드를 호출한 객체, 즉 메서드를 호출할 때 메서드 이름 앞의 마침표(.) 연산자 앞에 기술한 객체가 바인딩된다.</p>\n<p>주의 해야할 것은 this는 메서드를 소유한 객체가 아닌 메서드를 호출한 객체에 바인딩 된다는 것이다.</p>\n<br />\n<deckgo-highlight-code  terminal=\"carbon\"  >\n          <code slot=\"code\">const person = {\n\tname: &#39;Lee&#39;,\n    getName() {\n    \treturn this.name\n    }\n}\n\nconst anotherPerson = {\n\tname: &#39;Kim&#39;,\n}\n\nanotherPerson.getName = person.getName\n\nconsole.log(anotherPerson.getName()) // Kim\n\nconst getName = person.getName\n\nconsole.log(getName()) // &#39;&#39;\n</code>\n        </deckgo-highlight-code>\n<br />\nanotherPerson에 person의 getName 메서드를 할당했지만 this는 호출한 객체가 바인딩 되므로 Kim이 출력된다.\n<p>그리고 getName에도 person의 getName 메서드를 할당했지만 this는 전역 객체인 window의 name에 접근하게 된다.</p>\n<blockquote>\n<p>브라우저 환경에서 window.name은 브라우저 창의 이름을 나타내는 빌트인 프로퍼티이며 기본값은 ”이다.</p>\n</blockquote>\n<h2>생성자 함수 호출</h2>\n<p>생성자 함수 내부의 this는 생성자 함수가 (미래에) 생성할 인스턴스가 바인딩 된다.\n<br /></p>\n<deckgo-highlight-code  terminal=\"carbon\"  >\n          <code slot=\"code\">function Circle(radius) {\n\tthis.radius = radius,\n    getDiameter() {\n    \treturn 2*this.radius\n    }\n}\n\nconst circle1 = new Circle(5)\nconst circle2 = new Circle(10)\n\nconsole.log(circle1.getDiameter()) // 10\nconsole.log(circle2.getDiameter()) // 20</code>\n        </deckgo-highlight-code>\n<br />\n<h2>Function.prototype.apply/call/bind 메서드에 의한 간접 호출</h2>\n<h3>apply와 call</h3>\n<p>apply와 call 메서드의 본질적인 기능은 함수를 호출하는 것이다.\n함수를 호출하면서 첫 번째 인자로 전달한 특정 객체를 호출한 함수의 this에 바인딩한다.\n<br /></p>\n<deckgo-highlight-code  terminal=\"carbon\"  >\n          <code slot=\"code\">function getThisBinding() {\n\tconsole.log(arguments)\n\treturn this\n}\n\nconst thisArg = { a: 1}\n\nconsole.log(getThisBinding.apply(thisArg, [1, 2, 3]))\n// Arguments(3) [1, 2, 3, callee: f, Symbol.iterator): f]\n// {a: 1}\nconsole.log(getThisBinding.call(thisArg, 1, 2, 3)) // {a: 1}\n// Arguments(3) [1, 2, 3, callee: f, Symbol.iterator): f]\n// {a: 1}</code>\n        </deckgo-highlight-code>\n<br />\napply와 call 메서드는 호출할 함수에 인자를 전달하는 방식만 다를 뿐 동일하게 동작한다.\n<h3>bind</h3>\n<p>bind 메서드는 apply, call과 달리 함수를 바로 호출하지 않고 this로 사용할 객체만 전달한다.\n<br /></p>\n<deckgo-highlight-code  terminal=\"carbon\"  >\n          <code slot=\"code\">function getThisBinding() {\n\tconsole.log(arguments)\n\treturn this\n}\n\nconst thisArg = { a: 1}\n\nconsole.log(getThisBinding.bind(thisArg)) // getThisBinding\nconsole.log(getThisBinding.bind(thisArg)()) // { a: 1 }</code>\n        </deckgo-highlight-code>\n<br />\n그리고 bind 메서드는 메서드의 this와 메서드 내부의 중첩 함수 또는 콜백 함수의 this가 불일치하는 문제를 해결하기 위해 유용하게 사용된다.\n<br />\n<br />\n<deckgo-highlight-code  terminal=\"carbon\"  >\n          <code slot=\"code\">const person = {\n\tname: &#39;Lee&#39;,\n    foo(callback) {\n    \tsetTimeout((callback.bind(this), 100)\n    }\n}\n\nperson.foo(function () {\n\tconsole.log(this.name) // Lee\n})</code>\n        </deckgo-highlight-code>\n<br />\n<h2>이벤트 핸들러 안에서 쓴 this</h2>\n<p>이벤트 핸들러 안에서 쓰는 this는 이벤트를 받는 HTML 요소를 가리킨다.\n<br /></p>\n<deckgo-highlight-code  terminal=\"carbon\"  >\n          <code slot=\"code\">const button = document.querySelector(&#39;#btn&#39;)\nbutton.addEventListener(&#39;click&#39;, function {\n\tconsole.log(this) // #btn\n}</code>\n        </deckgo-highlight-code>\n<br />\n하지만 화살표 함수의 경우 상위 스코프의 this인 window를 가리킨다.\n<br />\n<br />\n<deckgo-highlight-code  terminal=\"carbon\"  >\n          <code slot=\"code\">const button = document.querySelector(&#39;#btn&#39;)\nbutton.addEventListener(&#39;click&#39;, () =&gt; {\n\tconsole.log(this) // window\n}</code>\n        </deckgo-highlight-code>\n<br />\n<blockquote>\n<p>참고 자료\n<a href=\"https://wikibook.co.kr/mjs/\" target=\"_blank\" rel=\"nofollow\">모던 자바스크립트 Deep Dive</a></p>\n</blockquote>","frontmatter":{"title":"[JS] this","summary":"JavaScript의 문법 중 this에 대해 알아보자.","date":"2021.10.28.","categories":["JavaScript"],"thumbnail":{"childImageSharp":{"gatsbyImageData":{"layout":"constrained","placeholder":{"fallback":"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAALCAIAAADwazoUAAAACXBIWXMAAAsTAAALEwEAmpwYAAABtklEQVQoz2P4cCsAF3p/M+D7g8B/z4I+3Ql8dyPg6/2A/8+D/z0L/nIPJPXhVgADHp3f7gee3OG5YIrT43N+Px8FXj3kM73bcc4Ex3unfL/eC3x/E7fmN9f9/78I7mywk5bTuXbE59YxHzs7I3VNPUUlXVdn40fn/D7fwa35LVhzf6u9qrruo3O+s/ud5BR0T2z3PLXTc/YEx3c3Aj7eJqS5r8VeWVX3/hnftfNc5RR0aktsHp/z/f8m5NMd3M5+fzPg9TWw5mZ7NXW9K4e8P9wKyEy2lJXX1dXVb6+1e4vH5s93Ar7cDfz3DGSzmobexf3e/18Ef3sUuGmxa1SouYy8zpROh9+Pg7Bo/ng74Pklv5PbPf+/D+lvsVdV07t+xOfCPu8dK9z+fw59dyfAytIwKdbi671AdM3vbgT8ehzU1QAKp7pSGztbI1sbo7fX/bNAbtapKLAuyraWU9DtqLf7hWnz+5sgB18/4pObamlmZujnbbpzpfuvR4F3TvhUFlpbWxlZWxnWltg8u4gjqiDJ49v9wFdX/T/cCvj+EBSwX+8F/ngY+Oaa/5vr/t8fBn6+CwptAJdrjPYzZvDjAAAAAElFTkSuQmCC"},"images":{"fallback":{"src":"/static/e9a85b5a3a7f83d86a85a4c348938bd5/ddad7/js.png","srcSet":"/static/e9a85b5a3a7f83d86a85a4c348938bd5/602a4/js.png 450w,\n/static/e9a85b5a3a7f83d86a85a4c348938bd5/4c0f7/js.png 900w,\n/static/e9a85b5a3a7f83d86a85a4c348938bd5/ddad7/js.png 1800w","sizes":"(min-width: 1800px) 1800px, 100vw"},"sources":[{"srcSet":"/static/e9a85b5a3a7f83d86a85a4c348938bd5/06689/js.webp 450w,\n/static/e9a85b5a3a7f83d86a85a4c348938bd5/eca74/js.webp 900w,\n/static/e9a85b5a3a7f83d86a85a4c348938bd5/23de5/js.webp 1800w","type":"image/webp","sizes":"(min-width: 1800px) 1800px, 100vw"}]},"width":1800,"height":1012}}}}}}]}},"pageContext":{"slug":"/[js]_this/"}},
    "staticQueryHashes": []}