{
    "componentChunkName": "component---src-templates-post-tsx",
    "path": "/객체지향/",
    "result": {"data":{"allMarkdownRemark":{"edges":[{"node":{"html":"<h1>1. 객체지향</h1>\n<hr>\n<h2>1.1 클래스 vs 객체 vs 인스턴스</h2>\n<hr>\n<ul>\n<li>\n<p>클래스란?</p>\n<ul>\n<li>공통된 속성과 행위를 수행하는 객체의 집합이다. 즉 객체를 정의하고 만들어 내기 위한 설계도</li>\n</ul>\n<deckgo-highlight-code language=\"jsx\" terminal=\"carbon\"  >\n          <code slot=\"code\">class 사람 {\n\t나이: ;\n\t성별: ;\n\n\t인사 () {\n\t\t안녕하세요..\n\t}\n}</code>\n        </deckgo-highlight-code>\n<p>클래스는 속성을 나타내는 필드와, 행위를 나타내는 메소드로 구성된다.</p>\n</li>\n<li>\n<p>객체란?</p>\n<ul>\n<li>클래스로 구현한 실체된 대상이다.</li>\n<li>즉, ‘나’는 사람이라는 클래스의 객체라고 볼 수 있다.</li>\n<li>객체는 클래스의 인스턴스라고 부른다.</li>\n</ul>\n</li>\n<li>\n<p>인스턴스란?</p>\n<ul>\n<li>클래스 설계도를 바탕으로 소프트웨어에서 구현된 구체적인 실체이다.</li>\n<li>즉, 객체를 소프트웨어에서 실체화 하면 그것을 <strong>인스턴스</strong>라고 부른다.</li>\n<li>실체화된 인스턴스는 메모리에 할당된다.</li>\n</ul>\n</li>\n<li>\n<p>객체 vs 인스턴스</p>\n<ul>\n<li>클래스 타입으로 선언한 것을 객체라 하고, 그 객체가 메모리에 할당 되어질때 (new) 인스턴스라고 한다.</li>\n<li>객체는 현실세계에 가깝고, 인스턴스는 관계의 초점에 가까운 개념</li>\n</ul>\n</li>\n</ul>\n<h2>1.2 상속과 다형성</h2>\n<hr>\n<ul>\n<li>\n<p><strong>상속</strong>\n객체지향에서 상속이란 어떤 클래스보다 좀 더 확장된 기능을 구현하고 싶을 때 새로 클래스를 구현하지 않고, 기존의 클래스를 상속받아서 속성이나 기능을 확장시키는 것을 말한다.</p>\n</li>\n<li>\n<p><strong>다형성</strong></p>\n<p>다형성이란 하나의 객체가 여러 가지 타입을 가질 수 있다는 것을 의미한다.</p>\n<p>예를 들어 상속을 이용한다면, 부모 클래스 타입의 참조 변수로 자식 클래스 타입의 인스턴스를 참조할 수 있도록 할 수 있다.</p>\n</li>\n<li>\n<p><strong>오버로딩(Overloading) vs 오버라이딩(Overriding)</strong></p>\n<ul>\n<li>오버로딩: 같은 이름의 메서드를 여러개 가지면서 매개변수의 유형과 개수가 다르게 하는 방법</li>\n</ul>\n<deckgo-highlight-code language=\"jsx\" terminal=\"carbon\"  >\n          <code slot=\"code\">class OverloadingTest{\n    cat(){\n        console.log(&quot;매개변수 없음&quot;);\n    }\n\n    cat(int a, int b){\n        console.log(&quot;매개변수 :&quot;+a+&quot;, &quot;+b);\n    }\n\n    cat(String c){\n        console.log(&quot;매개변수 : &quot;+ c);\n    }\n}\n</code>\n        </deckgo-highlight-code>\n<p>출처: <a href=\"https://private.tistory.com/25\" target=\"_blank\" rel=\"nofollow\">https://private.tistory.com/25</a> [공부해서 남 주자]</p>\n  <br />\n<ul>\n<li>\n<p>오버라이딩: 상위 클래스가 가지고 있는 메서드를 하위 클래스가 재정의 해서 사용하는 방법</p>\n<deckgo-highlight-code language=\"jsx\" terminal=\"carbon\"  >\n          <code slot=\"code\">class Woman{\n\tconstructor() {\n\t    this.name;\n\t    this.age;\n    }\n    info(){\n        console.log(&quot;여자의 이름은 &quot;+name+&quot;, 나이는 &quot;+age+&quot;살입니다.&quot;);\n    }\n\n}\n\nclass Job extends Woman{\n\t constructor() {\n\t    this.job;\n    }\n    info() {\n        super.info();\n        console.log(&quot;여자의 직업은 &quot;+job+&quot;입니다.&quot;);\n    }\n}\n\n출처: https://private.tistory.com/25 [공부해서 남 주자]</code>\n        </deckgo-highlight-code>\n</li>\n</ul>\n</li>\n<li>\n<p><strong>this vs super</strong>\nthis란 현재 클래스의 인스턴스를 의미하고, super란 상위 클래스의 인스턴스를 의미한다.</p>\n</li>\n</ul>\n<h1>2. 자바스크립트에서 객체지향</h1>\n<hr>\n<h2>2.1 object literal</h2>\n<hr>\n<p>자바스크립트는 오브젝트를 이용하여 객체를 표현할 수 있다.</p>\n<deckgo-highlight-code language=\"jsx\" terminal=\"carbon\"  >\n          <code slot=\"code\">const person = {\n  name: &#39;곽성준&#39;,\n  Age: 24,\n\n  info() {\n    console.log(&#39;이름: &#39; + this.name + &#39;나이: &#39; + this.age);\n  },\n};\n\nperson.info();</code>\n        </deckgo-highlight-code>\n<h2>2.2 Class (ES2016)</h2>\n<hr>\n<p>class가 생기고 class에서 제공하는 constructor라는 생성자가 주어짐.</p>\n<p>class를 new로 호출하면 생성자가 실행되고, 인스턴스를 반환한다.</p>\n<p>하지만 class는 prototype을 내부적으로 사용하고 있다.</p>\n<deckgo-highlight-code language=\"jsx\" terminal=\"carbon\"  >\n          <code slot=\"code\">class Person {\n  constructor(name, age) {\n    this.name = name;\n    this.age = age;\n  }\n  info() {\n    console.log(&#39;이름: &#39; + this.name + &#39;나이: &#39; + this.age);\n  }\n}\n\nconst person = new Person(&#39;곽성준&#39;, 24);\nperson.info();</code>\n        </deckgo-highlight-code>\n<h2>2.3 constructor pattern</h2>\n<hr>\n<p>function을 new 키워드로 호출하면 그 함수는 constructor가 된다.</p>\n<deckgo-highlight-code language=\"jsx\" terminal=\"carbon\"  >\n          <code slot=\"code\">const Person = function(name, age) {\n\t\tthis.name = name;\n\t\tthis.age = age\n\t\tthis.info() = function {\n\t\t    console.log(&#39;이름: &#39; + this.name + &#39;나이: &#39; + this.age);\n\t  }\n}\n\nconst person = new Person(&#39;곽성준&#39;, 24);\nperson.info();</code>\n        </deckgo-highlight-code>\n<h2>2.4 prototype</h2>\n<hr>\n<p>constructor 패턴과 유사하나, 메서드를 prototype객체에 보관해서 메모리 효율성에서 유리하다.</p>\n<ul>\n<li>자바스크립트에서 함수를 정의하고, 파싱 단계에 들어가면 내부적으로 수행되는 작업이 있다.</li>\n<li>함수 멤버로 prototype 속성이 생기고, 이 속성은 다른 곳에 생성된 함수이름의 프로토타입 객체를 참조한다.</li>\n</ul>\n<hr>\n<ul>\n<li>예를 들어 아래의 함수를 정의했다고 하자.</li>\n</ul>\n<deckgo-highlight-code language=\"jsx\" terminal=\"carbon\"  >\n          <code slot=\"code\">function Person() {}</code>\n        </deckgo-highlight-code>\n<ul>\n<li>속성이 하나도 없는 Person함수가 정의되고, 파싱단계에 들어가면, Person 함수 Prototype 속성은 프로토타입 객체를 참조한다.</li>\n<li>그리고 프로토타입 객체 멤버인 constructor 속성은 Person함수를 참조하는 구조를 가진다.</li>\n</ul>\n<p><img src=\"https://user-images.githubusercontent.com/72444675/157591335-ca2ec2f2-fb11-47b8-8242-dc06880641e3.png\" alt=\"스크린샷_2021-07-28_오전_12 11 54\"></p>\n<hr>\n<ul>\n<li>여기서 person 프로토타입 객체는 new라는 연산자와 Person함수를 통해 생성된 모든 객체의 원형이 되는 객체이다.</li>\n<li>예를 들어 Person함수를 new연산자를 이용해 생성한다면 아래와 같이 같은 프로토타입 객체를 참조한다.</li>\n</ul>\n<deckgo-highlight-code language=\"jsx\" terminal=\"carbon\"  >\n          <code slot=\"code\">function Person() {}\n\nconst joon = new Person();\nconst jisoo = new Person();</code>\n        </deckgo-highlight-code>\n<br />\n<p><img src=\"https://user-images.githubusercontent.com/72444675/157591360-c8d1a3e9-8a6d-4330-9e1b-2191350f029e.png\" alt=\"스크린샷_2021-07-28_오전_12 15 36\"></p>\n<ul>\n<li><strong>proto</strong> 란 비표준 속성이고, 이는 원형인 프로토타입 객체를 숨은 링크로 참조하는 역할을 한다.</li>\n</ul>\n<hr>\n<ul>\n<li>모든 객체는 프로토타입 객체에 접근할 수 있고, 프로토타입 객체 또한 동적으로 멤버를 가질 수 있다.</li>\n<li>예를 들어 아래와 같이 런타임에 멤버를 추가할 수 있다.</li>\n</ul>\n<deckgo-highlight-code language=\"jsx\" terminal=\"carbon\"  >\n          <code slot=\"code\">function Person() {}\n\nconst joon = new Person();\nconst jisoo = new Person();\n\nPerson.prototype.getType = function () {\n  return &#39;인간&#39;;\n};\n\nconsole.log(joon.getType()); //인간\nconsole.log(jisoo.getType()); //인간</code>\n        </deckgo-highlight-code>\n<br />\n<p><img src=\"https://user-images.githubusercontent.com/72444675/157591398-4cef7c9b-2229-43f5-85f9-2bd49fe6e245.png\" alt=\"스크린샷_2021-07-28_오전_12 20 46\"></p>\n<hr>\n<ul>\n<li>만약 동적으로 멤버를 추가할 때 프로토타입 객체를 사용하지 않는 다면 프로토타입 객체가 아닌 각각의 객체 안에 멤버가 추가된다.</li>\n</ul>\n<deckgo-highlight-code language=\"jsx\" terminal=\"carbon\"  >\n          <code slot=\"code\">joon.getType = function () {\n  return &#39;사람&#39;;\n};\n\nconsole.log(joon.getType()); //사람\nconsole.log(jisoo.getType()); //인간\n\njisso.age = 25;\n\nconsole.log(joon.age); // undefined\nconsole.log(jisoo.age); // 25</code>\n        </deckgo-highlight-code>\n<br />\n<p><img src=\"https://user-images.githubusercontent.com/72444675/157591460-2703e7e9-caaf-4350-9ac1-0b4cdd3fd210.png\" alt=\"스크린샷_2021-07-28_오전_12 23 58\"></p>\n<ul>\n<li>따라서 프로토타입 패턴을 사용하면 메서드를 따로 보관하지 않고, 프로토타입 객체에 보관해서 메모리 효율이 더 좋다.</li>\n</ul>\n<h2>2.5 class기반 vs prototype기반</h2>\n<hr>\n<ul>\n<li>클래스\n<ul>\n<li>클래스는 객체의 기본적인 구조와 기능을 먼저 정의한다.</li>\n<li>인스턴스는 특정 클래스의 양식을 기반으로 한다.</li>\n<li>즉, 모든 인스턴스의 구조는 동일하다.</li>\n</ul>\n</li>\n<li>프로토타입\n<ul>\n<li>클래스는 클래스 사이의 분류 관계에 초점을 맞추지만, 프로토타입은 여러가지 표본의 동작 방식에 초점을 맞춘다.</li>\n<li>프로토타입 기반 체계는 동적으로 구조를 정의할 수 있다.</li>\n</ul>\n</li>\n</ul>\n<h1>3. 객체지향 설계 (SOLID)</h1>\n<hr>\n<h2>3.1 SRP (단일 책임 원칙)</h2>\n<hr>\n<ul>\n<li>한 클래스는 하나의 책임만 가져야 하며, 그 기능을 완전히 캡슐화해야 한다.</li>\n<li>이는 어떤 변화에 의해 클래스를 변경해야 하는 이유는 오직 하나뿐이어야함을 의미한다.</li>\n<li>SRP는 책임 영역이 확실하기 때문에 다른 클래스와의 연쇄작용에서 자유로울 수 있다.</li>\n<li>따라서 코드의 가독성 향상, 재사용성 증진, 유지보수 용이라는 이점이 있다.</li>\n</ul>\n<h2>3.2 LSP (리스코프 치환 원칙)</h2>\n<hr>\n<ul>\n<li>프로그램의 객체는 프로그램의 정확성을 깨뜨리지 않으면서 하위 타입의 인스턴스로 바꿀 수 있어야 한다</li>\n<li>즉, 서브 타입은 언제나 기반 타입으로 교체할 수 있어야 한다.</li>\n<li>이는 다형성을 증진시키기 위한 목적이다.</li>\n</ul>\n<p><a href=\"https://medium.com/humanscape-tech/solid-%EB%B2%95%EC%B9%99-%E4%B8%AD-lid-fb9b89e383ef\" target=\"_blank\" rel=\"nofollow\">리스코프 치환 원칙 예시</a></p>","frontmatter":{"title":"객체지향","summary":"객체지향 패러다임에 대해 알아보자.","date":"2021.07.29.","categories":["CS"],"thumbnail":{"childImageSharp":{"gatsbyImageData":{"layout":"constrained","placeholder":{"fallback":"data:image/jpeg;base64,/9j/2wBDAAEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQH/2wBDAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQH/wgARCAAMABQDASIAAhEBAxEB/8QAGAAAAwEBAAAAAAAAAAAAAAAAAAgJAQf/xAAUAQEAAAAAAAAAAAAAAAAAAAAE/9oADAMBAAIQAxAAAAGmqJWP4K8LPGgHf//EABsQAAICAwEAAAAAAAAAAAAAAAUGAAcBAgMW/9oACAEBAAEFArkbTikLAuFk+ihEUOKYV04Hy2n/xAAdEQACAgMAAwAAAAAAAAAAAAABAgMRBBIhACJR/9oACAEDAQE/AZ4cl5kaHIESWm6FS+yqbdR7AKXHNqNfDyvP/8QAHhEAAwABBAMAAAAAAAAAAAAAAQIDBBESEyEAIiP/2gAIAQIBAT8Bx74k4US+IbUK046Cgnsdl0Rm+bF1Q+3HuUE6djvXz//EACMQAAICAQMDBQAAAAAAAAAAAAIDAQQFABETEhQiBhAhIzH/2gAIAQEABj8CwjsHbGk29lX17De1q2i4E4u5biNra3LWuGpBlhoJa0UAfGEzrEZ616oluOymUwdF+PsTWJdirkcwujKl4wIWqpMKdLE2UJQ0QkGT1kwwDSIyFRdrtmS5HJ1fWyQlZTEiQz5LKRKJ3Eon5jVlrUMusC4i0orjZPicJcnUIqhITuxYMnkFnmMTG357f//EABkQAQEBAQEBAAAAAAAAAAAAAAERACGx0f/aAAgBAQABPyFa5PlGLC0CM56qdV6kNp5G/PvuNhc4svaEagkhKCsQHCZLxOAVb//aAAwDAQACAAMAAAAQXw//xAAXEQEBAQEAAAAAAAAAAAAAAAABERAh/9oACAEDAQE/EAuloM/R+TeFuB//xAAXEQEAAwAAAAAAAAAAAAAAAAABECFR/9oACAECAQE/EK5rDhGZ7FKI/8QAHRABAAIBBQEAAAAAAAAAAAAAAQARIRAxUZGhYf/aAAgBAQABPxDPHReraCAf2aIJULh04MouJWZ5HSDwl8iJKf7lfhW7A/rOqm4ae7mIqtvr22+z/9k="},"images":{"fallback":{"src":"/static/7231dfd36025afc82790484ce5feec4b/b37b0/cs.jpg","srcSet":"/static/7231dfd36025afc82790484ce5feec4b/9cf2b/cs.jpg 250w,\n/static/7231dfd36025afc82790484ce5feec4b/3a8a8/cs.jpg 500w,\n/static/7231dfd36025afc82790484ce5feec4b/b37b0/cs.jpg 1000w","sizes":"(min-width: 1000px) 1000px, 100vw"},"sources":[{"srcSet":"/static/7231dfd36025afc82790484ce5feec4b/40603/cs.webp 250w,\n/static/7231dfd36025afc82790484ce5feec4b/7a96c/cs.webp 500w,\n/static/7231dfd36025afc82790484ce5feec4b/51449/cs.webp 1000w","type":"image/webp","sizes":"(min-width: 1000px) 1000px, 100vw"}]},"width":1000,"height":600}}}}}}]}},"pageContext":{"slug":"/객체지향/"}},
    "staticQueryHashes": []}