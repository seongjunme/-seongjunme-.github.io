{
    "componentChunkName": "component---src-templates-post-tsx",
    "path": "/프로세스와스레드/",
    "result": {"data":{"allMarkdownRemark":{"edges":[{"node":{"html":"<h1>1. 프로세스와 스레드</h1>\n<h2>1.1 프로세스</h2>\n<hr>\n<ul>\n<li>\n<p>프로세스란</p>\n<ul>\n<li>OS에서 메모리 영역을 할당받아 실행되는 독립적인 프로그램 인스턴스</li>\n<li>하나의 프로세스는 별도의 메모리 공간을 할당 받아 사용</li>\n<li>즉, 동적인 개념으로는 실행된 프로그램을 의미</li>\n</ul>\n</li>\n<li>\n<p>할당 받는 메모리 공간</p>\n<img src=\"https://user-images.githubusercontent.com/72444675/159236544-b958be1d-76d2-43ca-a3fb-713664e0fc4d.png\" width=\"700px\">\n<ul>\n<li>프로세스는 각각 독립된 메모리 영역 (code, data, stack, heap)을 할당받는다.</li>\n<li>프로세스는 기본적으로 최소 1개의 스레드(메인 스레드)를 가지고 있다.</li>\n<li>서로 다른 프로세스의 메모리 영역은 접근할 수 없다.</li>\n<li>다른 프로세스의 메모리 영역에 접근하려면 통신을 사용해야한다.</li>\n</ul>\n</li>\n</ul>\n<h2>1.2 스레드</h2>\n<hr>\n<ul>\n<li>\n<p>스레드란</p>\n<ul>\n<li>프로세스 내에서 실행되는 여러 흐름의 단위</li>\n<li>프로세스가 할당받은 자원을 이용하는 실행 단위</li>\n</ul>\n</li>\n<li>\n<p>특징</p>\n<img src=\"https://user-images.githubusercontent.com/72444675/159236810-9701973b-32ea-444a-a779-6b19d0514577.png\" width=\"700px\">\n<ul>\n<li>스레드는 프로세스 내에서 각각 Stack만 따로 할당받고 나머지 영역은 공유한다.</li>\n<li>스레드는 한 프로세스 내의 주소 공간이나 자원을 같은 프로세스 내의 스레드끼리 공유한다.</li>\n</ul>\n</li>\n</ul>\n<h2>1.3 멀티 프로세스</h2>\n<hr>\n<ul>\n<li>\n<p>멀티 프로세싱이란</p>\n<ul>\n<li>하나의 응용 프로그램을 여러 개의 프로세스로 구성하여 각 프로세스가 하나의 작업을 처리하도록 하는 것이다</li>\n</ul>\n</li>\n<li>\n<p>장점</p>\n<ul>\n<li>멀티 프로세싱은 프로세스간 공유하는 자원이 없기 때문에, 동일한 자원에 동시에 접근해서 발생하는 critical section문제(dead lock)가 발생하지 않는다.</li>\n</ul>\n</li>\n<li>\n<p>단점</p>\n<ul>\n<li>프로세스를 번갈아가면서 실행시키기 때문에 context switch 과정에서 오버헤드가 발생한다.</li>\n</ul>\n</li>\n</ul>\n<h2>1.4 멀티 스레딩</h2>\n<hr>\n<ul>\n<li>\n<p>멀티 스레딩이란</p>\n<ul>\n<li>하나의 응용 프로그램을 여러 개의 스레드로 구성하고, 각 스레드가 하나의 작업을 처리하는 것이다.</li>\n</ul>\n</li>\n<li>\n<p>장점</p>\n<ul>\n<li>\n<p>시스템 자원 소모 감소</p>\n<ul>\n<li>프로세스를 생성하여 자원을 할당하는 시스템 콜이 줄어들어 자원을 효율적으로 관리할 수 있다.</li>\n</ul>\n</li>\n<li>\n<p>시스템 처리량 증가</p>\n<ul>\n<li>스레드 간 데이터를 주고 받는 것이 간단해지고 시스템 자원 소모가 줄어들게 된다.</li>\n</ul>\n</li>\n<li>\n<p>스레드는 프로세스 내의 Stack 영역을 제외한 모든 메모리를 공유하기 때문에 통신의 부담이 적다.</p>\n</li>\n</ul>\n</li>\n<li>\n<p>단점</p>\n<ul>\n<li>상당히 복잡해질 수 있다.</li>\n<li>디버깅이 힘들다</li>\n<li>데드락 가능성 증가\n<a href=\"https://gmlwjd9405.github.io/2018/09/14/process-vs-thread.html\" target=\"_blank\" rel=\"nofollow\">https://gmlwjd9405.github.io/2018/09/14/process-vs-thread.html</a></li>\n</ul>\n</li>\n</ul>\n<h1>2. 스케줄링</h1>\n<h2>2.1 프로세스 상태</h2>\n<hr>\n<ul>\n<li>\n<p>프로세스는 다음 5가지 상태 중 하나를 가진다.</p>\n<ul>\n<li>생성(create): 프로세스가 생성되는 중이다.</li>\n<li>실행(running): 프로세스가 자원을 할당받아 실행되는 중이다.</li>\n<li>준비(ready): 프로세스가 자원을 사용하고 있지 않지만, 언제든 자원을 받아 실행할 수 있는 상태</li>\n<li>대기(waiting): 프로세스가 입출력 완료, 시그널 수신 등 어떤 사건을 기다리고 있는 상태 (인터럽트 발생)</li>\n<li>종료(terminated): 프로세스가 종료된 상태</li>\n</ul>\n<img src=\"https://user-images.githubusercontent.com/72444675/159237008-c1c5870c-9d51-47e9-867c-bd2e53a21700.png\" width=\"700px\">\n</li>\n</ul>\n<h2>2.2 스케줄링</h2>\n<hr>\n<p>OS는 준비 큐(Ready Queue), 대기 큐(Waiting Queue) 등의 자료구조를 두어 프로세스를 관리한다. 준비 큐는 ready상태에 있는 프로세스들을 모아놓은 큐이다. OS는 CPU 스케줄러를 통해 준비 큐에 있는 프로세스 중 한 프로세스를 골라 다음에 실행시킨다.</p>\n<h3>선점과 비선점</h3>\n<hr>\n<p>프로세스 스케줄링은 다음 네 가지 경우에 일어날 수 있다.</p>\n<ul>\n<li>프로세스가 실행 상태(running)에서 대기 상태(waiting)으로 전환될 때</li>\n<li>프로세스가 실행 상태(running)에서 준비 상태(ready)로 전환될 때</li>\n<li>프로세스가 대기 상태(waiting)에서 준비 상태(ready)로 전환될 때</li>\n<li>프로세스가 종료되었을 때(terminated)</li>\n</ul>\n<p>만약 프로세스 스케줄링이 첫 번째와 네 번째 경우에만 일어난다면 이를 비선점 스케줄링이라 한다. 즉, 인터럽트나, 종료가 아니면 프로세스 전환이 일어나지 않는다.</p>\n<p>그렇지 않고 일정 규칙을 두어 프로세스 전환이 일어난다면, 즉 위 네 가지의 모든 경우에서 스케줄링이 일어난다면 이를 선점형 스케줄링이라 한다.</p>\n<h3>FCFS (First Come First Served)</h3>\n<hr>\n<ul>\n<li>선입선출</li>\n<li>비선점형 스케줄링</li>\n<li>응답시간이 길어질 수 있음</li>\n<li>다른 프로세스가 끝날 때까지 기다려야한다.</li>\n</ul>\n<h3>SJF(Shortest Job First)</h3>\n<hr>\n<ul>\n<li>CPU burst time이 짧은 프로세스를 우선으로 할당하는 방법</li>\n<li>일종의 우선순위 기법</li>\n<li>비선점형과 선점형 모두 존재</li>\n<li>최소 평균 대기 시간을 보장한다.</li>\n<li>기아 현상 발생 가능성이 있다. (원래있던 프로세스보다 burst time이 짧은 프로세스가 계속 들어오면, 원래 프로세스는 계속 실행되지 못함)</li>\n</ul>\n<h3>SRTF(Shortest Remaining Time First)</h3>\n<hr>\n<ul>\n<li>SJF의 선점형 스케줄링 방식</li>\n<li>남은 프로세스의 burst time 보다 더 짧은 프로세스가 도착하면 CPU를 빼앗음</li>\n<li>프로세스가 새로 들어올 때마다 갱신된다.</li>\n<li>스케줄링이 비규칙적으로 변경되어 cpu 사용시간을 정확히 예측하기 어렵다.</li>\n</ul>\n<h3>Priority Scheduling</h3>\n<hr>\n<ul>\n<li>Highest Priority를 가진 프로세스에게 CPU를 할당</li>\n<li>선점형 방식에서는 새로 도착한 프로세스의 우선순위가 현재 실행되는 프로세스보다 높으면 CPU를 선점한다.</li>\n<li>비선점 방식에서는 더 높은 우선순위의 프로세스가 들어오면 Ready queue의 head 부분에 넣는다.</li>\n<li>기아 현상 발생 ( 우선순위가 계속 낮을 경우 실행되지 못함 )\n<ul>\n<li>Aging 기법으로 해결 가능 ( 한번 실행된 프로세스는 우선순위가 조금씩 낮아지는 방법 )</li>\n</ul>\n</li>\n</ul>\n<h3>RR(Round Robin)</h3>\n<hr>\n<ul>\n<li>선점형 스케줄링 방식</li>\n<li>각 프로세스는 동일한 할당 시간을 가지고, 할당 시간이 지나면 다른 프로세스에게 자원을 선점 당한 뒤, Ready queue의 맨 위로 가게 된다.</li>\n<li>모든 프로세스에게 공정한 방식</li>\n<li>평균 대기 시간이 길어질 수 있으나, 응답 시간이 짧아 진다.</li>\n<li>Context switching 오버헤드</li>\n</ul>","frontmatter":{"title":"프로세스와 스레드","summary":"프로세스와 스레드에 대해 알아보자.","date":"2021.08.03.","categories":["CS"],"thumbnail":{"childImageSharp":{"gatsbyImageData":{"layout":"constrained","placeholder":{"fallback":"data:image/jpeg;base64,/9j/2wBDAAEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQH/2wBDAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQH/wgARCAAMABQDASIAAhEBAxEB/8QAGAAAAwEBAAAAAAAAAAAAAAAAAAgJAQf/xAAUAQEAAAAAAAAAAAAAAAAAAAAE/9oADAMBAAIQAxAAAAGmqJ2O4E8LQmgHf//EABsQAAICAwEAAAAAAAAAAAAAAAUGAAcBAgMW/9oACAEBAAEFArkbTqkLAuFk+ihEUOKYVk8Jz2n/xAAdEQACAgIDAQAAAAAAAAAAAAABAgMRBBIQISJR/9oACAEDAQE/AZ4cl5kaLIESWhdCpbZVNuo9AKWHW1NXzj//xAAeEQADAAEEAwAAAAAAAAAAAAABAgMEERITIQAiI//aAAgBAgEBPwHHyMScKJfENqFacdBQT2Oy6IzfNmdZn249ygnTsd6+f//EACQQAAICAQMDBQEAAAAAAAAAAAIDAQQFABITERQjBhAhIjEy/9oACAEBAAY/AsI/BWxpNvZSxXsN7WtaLgTi7luI6WluWtcNSDHtFLWigD4wmdYjPWvU8tx+VymDovx9iaxKsVcjmF0ZUGMDjVUmFOlqbCEoaIyDJ5CYYBpEZCoq12zZcjk3eNkrJZTG0h/oCkCieolE/Masschl1gXK9pRXGb+JwlybwFcKCfIsGeQT+4xMdPz2/8QAGhABAAMAAwAAAAAAAAAAAAAAAQARITGx0f/aAAgBAQABPyFSJXrjBiVSLMeD5QMLJkfYgx73DEHJBpbNUqEmUnxBN8Fjr4XELU//2gAMAwEAAgADAAAAEJ8P/8QAFxEAAwEAAAAAAAAAAAAAAAAAAREhAP/aAAgBAwEBPxAEsqDuhn48BNRb/8QAGBEBAQADAAAAAAAAAAAAAAAAAREQITH/2gAIAQIBAT8QCYhDiOinQKXJh//EABwQAQACAgMBAAAAAAAAAAAAAAEAEZGhITFRYf/aAAgBAQABPxC2EU9++HV5EJFZSrF897RGqrOfRhBohc3ElMOI+4Veou2jGPyoeyIxlV19ctu5/9k="},"images":{"fallback":{"src":"/static/7231dfd36025afc82790484ce5feec4b/b37b0/cs.jpg","srcSet":"/static/7231dfd36025afc82790484ce5feec4b/9cf2b/cs.jpg 250w,\n/static/7231dfd36025afc82790484ce5feec4b/3a8a8/cs.jpg 500w,\n/static/7231dfd36025afc82790484ce5feec4b/b37b0/cs.jpg 1000w","sizes":"(min-width: 1000px) 1000px, 100vw"},"sources":[{"srcSet":"/static/7231dfd36025afc82790484ce5feec4b/40603/cs.webp 250w,\n/static/7231dfd36025afc82790484ce5feec4b/7a96c/cs.webp 500w,\n/static/7231dfd36025afc82790484ce5feec4b/51449/cs.webp 1000w","type":"image/webp","sizes":"(min-width: 1000px) 1000px, 100vw"}]},"width":1000,"height":600}}}}}}]}},"pageContext":{"slug":"/프로세스와스레드/"}},
    "staticQueryHashes": []}