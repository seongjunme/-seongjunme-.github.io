{
    "componentChunkName": "component---src-templates-post-tsx",
    "path": "/메모리/",
    "result": {"data":{"allMarkdownRemark":{"edges":[{"node":{"html":"<h1>1. 일반 메모리 구조</h1>\n<hr>\n<p>프로그램이 실행되기 위해선 OS가 프로그램을 메모리에 로드 해야한다.</p>\n<p>이 때 메모리에 프로그램의 코드와 변수들이 로드 된다.</p>\n<p>따라서 메모리 공간을 다음과 같이 나눠 구분한다.</p>\n<br />\n<img width=\"700\" alt=\"1625800634797Screen_Shot_2021-07-09_at_12 14 43_PM\" src=\"https://user-images.githubusercontent.com/72444675/157589758-533a9b33-75cd-4bb4-943d-785404e47fd4.png\">\n<br />\n<h3>TEXT 영역</h3>\n<ul>\n<li>\n<p>프로그램에 있는 함수 코드, 제어문, 상수들이 저장되는 영역이다.</p>\n</li>\n<li>\n<p>실행할 코드는 프로그래머가 작성한 코드를 의미하고, 프로그램이 종료될 때 까지 메모리에 계속 남아있는다.</p>\n</li>\n<li>\n<p>CPU는 이 영역에 저장된 명령어를 하나씩 가져와 처리한다.</p>\n</li>\n<li>\n<p>GVAR/BSS 섹션</p>\n<ul>\n<li>범위(Scope)가 정해지지 않은 전역(Global) 변수를 포함한다.</li>\n<li>GVAR는 초기값을 0이 아닌 특정한 값으로 지정한 경우 사용한다.</li>\n</ul>\n</li>\n</ul>\n<h3>STACK 영역</h3>\n<ul>\n<li>\n<p>함수를 호출할 때마다 지역 변수, 매개 변수가 저장되는 영역이다.</p>\n</li>\n<li>\n<p>함수의 호출과 함께 할당 되며 리턴 시 소멸한다.</p>\n</li>\n<li>\n<p>예시</p>\n</li>\n</ul>\n<deckgo-highlight-code language=\"jsx\" terminal=\"carbon\"  >\n          <code slot=\"code\">function main() {\n  func1();\n}\n\nfunction func1() {\n  func2();\n}\n\nfunction func2() {\n  return;\n}\n\nmain();</code>\n        </deckgo-highlight-code>\n  <br />\n<p><img src=\"https://user-images.githubusercontent.com/72444675/157589872-06af33eb-8f99-46a1-bc93-f5e4045f1c90.png\" alt=\"img_c_stackframe_01 (1)\"></p>\n<br />\n<p>Step1. main()에서 func1()이 실행되면 관련 값들이 스택에 적재된다.</p>\n<ul>\n<li>매개변수</li>\n<li>반환 주소 값 ( 함수 리턴 시 컨트롤 포인터를 어디로 반환할지 지정해주기 위한 값이다.)</li>\n<li>지역변수</li>\n</ul>\n<br />\n<p>Step2. func2(), … 함수들이 차례로 적재된다.</p>\n  <br />\n<p><img src=\"https://user-images.githubusercontent.com/72444675/157589954-b00d9b5d-fb9d-4ddd-a3d2-bbf8e2eb082d.png\" alt=\"img_c_stackframe_02 (1)\"></p>\n<br />\n<p>Step3. func2()가 종료되면 리턴 시 관련 변수(매개변수, 반환 주소, 지역변수)들이 스택에서 삭제 된다.</p>\n<br />\n<p>Step4. func2()가 종료됨에 따라 func1(), main() 또한 스택에서 제거 된다.</p>\n<br />\n<p><a href=\"http://tcpschool.com/c/c_memory_stackframe\" target=\"_blank\" rel=\"nofollow\">출처: http://tcpschool.com/c/c_memory_stackframe</a></p>\n<br />\n<h3>HEAP 영역</h3>\n<ul>\n<li>힙 영역은 사용자가 직접 관리할 수 있는 영역이다.</li>\n<li>메모리 공간이 동적으로 할당되고 해제된다.</li>\n<li>힙 영역에 할당한 메모리 공간에 대한 주소를 참조하는 경우가 많다.</li>\n<li>스택과 힙의 연관 예시</li>\n</ul>\n<br />\n<p><img src=\"https://user-images.githubusercontent.com/72444675/157590278-12b0bb38-8fd7-4b50-b3ee-d982d8cd8bd3.png\" alt=\"스크린샷_2021-07-22_오후_9 06 41\"></p>\n<p>스택에 동적 할당된 Heap의 주소 값이 저장 되며, 참조할 수 있다.</p>\n<h1>2. V8 엔진 메모리 구조</h1>\n<hr>\n<p>자바스크립트를 실행할 수 있는 Node.js의 기반인 V8엔진 메모리 구조를 살펴보자. 먼저 힙과 스택으로 크게 구분되어 있는 것을 볼 수 있다.</p>\n<h3>2.1 V8 메모리 영역</h3>\n<hr>\n<p><img src=\"https://user-images.githubusercontent.com/72444675/157590328-22a85e48-9614-4729-b756-7129b6c79812.png\" alt=\"0_SM_Ja0xN9q54Lpqf (1)\"></p>\n<h3>힙 메모리 영역</h3>\n<ul>\n<li>New space 영역\n<ul>\n<li>새로 만들어진 모든 객체를 저장하고 이 객체들은 짧은 생명 주기를 가진다.</li>\n<li>이 영역은 크기가 작고 JVM에서 S0, S1과 같은 2개의 세미(semi) 영역을 가진다.</li>\n</ul>\n</li>\n<li>Old space 영역\n<ul>\n<li>New space 영역에서 살아남은 객체들이 이동하는 영역이다.</li>\n<li>Old 포인터 영역은 살아남은 객체들이 저장되고, 이 객체들은 다른 객체를 참조한다.</li>\n<li>Old 데이터 영역은 데이터만 가진 객체들(참조 x)이 저장된다.</li>\n</ul>\n</li>\n<li>Large obejct 영역\n<ul>\n<li>다른 영역의 제한된 크기보다 큰 객체들이 살고 있는 영역이다.</li>\n<li>각 객체는 자체 mmap 메모리 영역을 갖는다.</li>\n<li>Large object들은 가비지 컬렉터로 이동하지 않는다.</li>\n</ul>\n</li>\n<li>Code space 영역\n<ul>\n<li>실시간 컴파일러가 컴파일된 코드들을 저장하는 곳이다.</li>\n<li>유일하게 실행 가능한 메모리가 있는 영역이다.</li>\n</ul>\n</li>\n<li>Cell, Property, Map space 영역\n<ul>\n<li>이 영역들은 각각 Cells, PropertyCells, Maps를 포함한다.</li>\n<li>각 영역은 모두 같은 크기의 객체들을 포함하며, 어떤 종류의 객체를 참조하는지에 대한 제약이 있어서 수집을 단순하게 만든다.</li>\n</ul>\n</li>\n</ul>\n<h3>스택 영역</h3>\n<ul>\n<li>스택은 메모리 영역이고 V8 프로세스마다 하나의 스택을 갖는다.</li>\n<li>스택은 메서드와 함수 프레임, 원시 값, 객체 포인터를 포함한 정적 데이터가 저장되는 곳이다.</li>\n</ul>\n<h3>2.2 V8 메모리 관리: 가비지 컬렉션</h3>\n<hr>\n<p>V8 엔진이 힙 메모리를 어떻게 관리하는지 알아보자.</p>\n<ul>\n<li><strong>가비지 컬렉션이란?</strong>\n애플리케이션이 할당한 메모리 공간을 주기적으로 검사하여 더 이상 사용되지 않는 메모리를 해제하는 기능을 말한다.\n더 이상 사용되지 않는 메모리란 간단히 말하자면 어떤 식별자도 참조하지 않는 메모리 공간을 의미한다.</li>\n<li>가비지 컬렉션이 필요한 이유?\n<ul>\n<li>javascript에서는 malloc과 free와 같은 함수를 사용해서 메모리 컨트롤을 하지 않는다.</li>\n<li>따라서 메모리의 최대 용량을 사용하려 하면 메모리 부족 현상이 발생한다. (memory leak)</li>\n<li>위의 문제를 방지하기 위해 가비지 컬렉션이 필요하다.</li>\n</ul>\n</li>\n</ul>\n<h1>3. 가상 메모리</h1>\n<hr>\n<h3>3.1 가상 메모리란 ?</h3>\n<hr>\n<p>메모리 관리 기법의 하나로, 실제 자원을 추상화 하여 사용자에게 마치 메모리를 전부? 사용하는 듯한 느낌을 주는 방식이다.</p>\n<p>즉, 실제로 존재하지는 않지만 가상의 메모리 주소를 부여해 사용자에게 있어 메모리 역할을 하는 가상의 자원이다. 그러나 가상메모리에 수용된 프로그램이 실행될 때는 실제 메모리를 사용해야한다.</p>\n<ul>\n<li>가상 메모리와 실제 메모리의 관계\n가상 메모리 안에 프로그램이 실행될 때는 실제 메모리에 반드시 있어야 한다.\n하지만 프로그램의 전체가 실제 메모리에 있을 필요는 없다.\n즉, 당장 필요한 부분만 실제 메모리에 적재시켜 메모리를 효율적으로 사용할 수 있게된다.\n따라서 실제 메모리 보다 큰 용량을 가진 프로그램도 가상 메모리 기법을 통해 실행 시킬 수 있는 것 이다.</li>\n</ul>\n<h3>3.2 Paging</h3>\n<hr>\n<p>앞서 말한 가상메모리를 이용하기 위해 Paging이란 기법이 사용된다.</p>\n<ul>\n<li>Paging 기법이란 가상 메모리와 실제 메모리를 매핑하기 위한 기술이다.</li>\n<li>Paging 방식에서는 가상 메모리와 실제 메모리를 page와 frame을 단위로 나누어 사용한다.</li>\n<li>그리고 매핑을 위한 Page Table이 존재한다.</li>\n</ul>\n<p><img src=\"https://user-images.githubusercontent.com/72444675/157590447-fee504da-0898-442b-864c-64c5f6352d76.jpeg\" alt=\"d0029308_1131883 (1)\"></p>\n<p>출처: <a href=\"http://board.theko.co.kr/bbs/board.php?bo_table=linux_ETC&#x26;wr_id=9&#x26;sfl=&#x26;stx=&#x26;sst=wr_hit&#x26;sod=asc&#x26;sop=and&#x26;page=2\" target=\"_blank\" rel=\"nofollow\">http://board.theko.co.kr/</a></p>\n<p>따라서 Paging 기법을 이용한 가상메모리는 실제 메모리에 연속적으로 적재되지 않아도 마치 연속적으로 적재된 것 처럼 이용할 수 있다.</p>\n<h1>4. Process 노드 모듈</h1>\n<hr>\n<h3>4.1 Process 객체란 ?</h3>\n<hr>\n<p>프로그램을 실행 했을 때 만들어지는 프로세스 정보를 다루는 객체</p>\n<h3>4.2 Process 객체의 주요 속성과 메소드</h3>\n<hr>\n<ul>\n<li>시스템 정보 관련</li>\n</ul>\n<deckgo-highlight-code language=\"jsx\" terminal=\"carbon\"  >\n          <code slot=\"code\">console.log(process.env); // 컴퓨터 환경과 관련된 정보를 가진 객체\nconsole.log(process.version); // node.js의 버전\nconsole.log(process.versions); // node.js와 연관된 프로그램들의 버전을 가진 객체\nconsole.log(process.arch); // 프로세서의 아키텍처(arm/ia32/x64)\nconsole.log(process.platform); // 플랫폼(win32/linux/sunos/freebsd/darwin)\nconsole.log(process.memoryUsage()); // 메모리 사용 정보를 가진 객체\nconsole.log(process.uptime()); // 현재 프로그램이 실행된 시간</code>\n        </deckgo-highlight-code>\n<ul>\n<li>프로세스를 실행할 때 전달되는 파라미터 정보</li>\n</ul>\n<p>예제</p>\n<deckgo-highlight-code language=\"jsx\" terminal=\"carbon\"  >\n          <code slot=\"code\">process.argv.forEach(function (val, index, array) {\n  console.log(index + &#39;: &#39; + val);\n});</code>\n        </deckgo-highlight-code>\n<p>실행</p>\n<deckgo-highlight-code language=\"jsx\" terminal=\"carbon\"  >\n          <code slot=\"code\">$ node processArgv.js one two three\n0: node\n1: /(path)/processArgv.js\n2: one\n3: two\n4: three</code>\n        </deckgo-highlight-code>\n<ul>\n<li>프로세스 종료</li>\n</ul>\n<deckgo-highlight-code language=\"jsx\" terminal=\"carbon\"  >\n          <code slot=\"code\">$ node\n&gt; console.log(&quot;REPL을 실행한 화면입니다.&quot;);\nREPL을 실행한 화면입니다.\nundefined\n&gt; process.exit();\n$</code>\n        </deckgo-highlight-code>\n<p>exit()에 매개변수를 넘겨 줄 수 있고, 0은 정상 종료, 1은 비정상 종료를 의미한다.</p>\n<p><a href=\"https://opentutorials.org/module/938/7189\" target=\"_blank\" rel=\"nofollow\">출처: opentutorials.org</a></p>","frontmatter":{"title":"메모리 구조","summary":"메모리 구조와 가상 메모리에 대해 알아보자.","date":"2021.07.27.","categories":["CS"],"thumbnail":{"childImageSharp":{"gatsbyImageData":{"layout":"constrained","placeholder":{"fallback":"data:image/jpeg;base64,/9j/2wBDAAEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQH/2wBDAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQH/wgARCAAMABQDASIAAhEBAxEB/8QAGAAAAwEBAAAAAAAAAAAAAAAAAAgJAQf/xAAUAQEAAAAAAAAAAAAAAAAAAAAE/9oADAMBAAIQAxAAAAGmqJ2O4E8LQmgHf//EABsQAAICAwEAAAAAAAAAAAAAAAUGAAcBAgMW/9oACAEBAAEFArkbTqkLAuFk+ihEUOKYVk8Jz2n/xAAdEQACAgIDAQAAAAAAAAAAAAABAgMRBBIQISJR/9oACAEDAQE/AZ4cl5kaLIESWhdCpbZVNuo9AKWHW1NXzj//xAAeEQADAAEEAwAAAAAAAAAAAAABAgMEERITIQAiI//aAAgBAgEBPwHHyMScKJfENqFacdBQT2Oy6IzfNmdZn249ygnTsd6+f//EACQQAAICAQMDBQEAAAAAAAAAAAIDAQQFABITERQjBhAhIjEy/9oACAEBAAY/AsI/BWxpNvZSxXsN7WtaLgTi7luI6WluWtcNSDHtFLWigD4wmdYjPWvU8tx+VymDovx9iaxKsVcjmF0ZUGMDjVUmFOlqbCEoaIyDJ5CYYBpEZCoq12zZcjk3eNkrJZTG0h/oCkCieolE/Masschl1gXK9pRXGb+JwlybwFcKCfIsGeQT+4xMdPz2/8QAGhABAAMAAwAAAAAAAAAAAAAAAQARITGx0f/aAAgBAQABPyFSJXrjBiVSLMeD5QMLJkfYgx73DEHJBpbNUqEmUnxBN8Fjr4XELU//2gAMAwEAAgADAAAAEJ8P/8QAFxEAAwEAAAAAAAAAAAAAAAAAAREhAP/aAAgBAwEBPxAEsqDuhn48BNRb/8QAGBEBAQADAAAAAAAAAAAAAAAAAREQITH/2gAIAQIBAT8QCYhDiOinQKXJh//EABwQAQACAgMBAAAAAAAAAAAAAAEAEZGhITFRYf/aAAgBAQABPxC2EU9++HV5EJFZSrF897RGqrOfRhBohc3ElMOI+4Veou2jGPyoeyIxlV19ctu5/9k="},"images":{"fallback":{"src":"/static/7231dfd36025afc82790484ce5feec4b/b37b0/cs.jpg","srcSet":"/static/7231dfd36025afc82790484ce5feec4b/9cf2b/cs.jpg 250w,\n/static/7231dfd36025afc82790484ce5feec4b/3a8a8/cs.jpg 500w,\n/static/7231dfd36025afc82790484ce5feec4b/b37b0/cs.jpg 1000w","sizes":"(min-width: 1000px) 1000px, 100vw"},"sources":[{"srcSet":"/static/7231dfd36025afc82790484ce5feec4b/40603/cs.webp 250w,\n/static/7231dfd36025afc82790484ce5feec4b/7a96c/cs.webp 500w,\n/static/7231dfd36025afc82790484ce5feec4b/51449/cs.webp 1000w","type":"image/webp","sizes":"(min-width: 1000px) 1000px, 100vw"}]},"width":1000,"height":600}}}}}}]}},"pageContext":{"slug":"/메모리/"}},
    "staticQueryHashes": []}