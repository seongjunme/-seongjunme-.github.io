{
    "componentChunkName": "component---src-templates-post-tsx",
    "path": "/LRU/",
    "result": {"data":{"allMarkdownRemark":{"edges":[{"node":{"html":"<h1>LRU</h1>\n<hr>\n<p>LRU 알고리즘이란 가장 오랫동안 참조되지 않은 페이지를 교체하는 기법이다.</p>\n<p>캐시 교체 알고리즘에 많이 사용된다.</p>\n<h3>3.1 캐시란?</h3>\n<hr>\n<p>캐시란 자주 사용하는 데이터를 미리 복사 담아두는 임시 장소를 의미한다.</p>\n<p>예를들어 캐시는 메모리와 레지스터 사이에 존재하는 하나의 메모리로 사용된다.</p>\n<p>메모리의 용량이 커질 수록 CPU에서 메모리를 탐색하는 시간 또한 길어진다.</p>\n<p>때문에 CPU 처리 속도와 메모리 탐색 시간 사이의 격차가 발생하게 된다.</p>\n<p>따라서 이 격차를 해소하기 위해 캐시 메모리를 사용할 수 있다.</p>\n<p><strong>즉, 자주 사용하는 특정 값을 캐시에 올려 CPU가 더욱 빨리 접근할 수 있도록 도와준다!</strong></p>\n<h3>3.2 캐시의 동작</h3>\n<hr>\n<p>CPU가 메모리에 접근하기 전에 먼저 캐시 메모리에서 원하는 데이터가 있는지 확인한다.</p>\n<ol>\n<li>만약 있다면 <strong>적중(hit)</strong></li>\n<li>없는 경우엔 **실패(miss)**라고 한다.</li>\n</ol>\n<p>이 때 데이터를 캐시에서 찾을 확률을 적중률(hit ratio)라고 한다.</p>\n<p>캐시 메모리의 성능을 이 적중률에 의해 결정된다.</p>\n<h3>3.3 캐시 교체 정책</h3>\n<hr>\n<p>캐시 교체 알고리즘의 예로 3가지를 살펴본다.</p>\n<ul>\n<li>FIFO : 캐시에 적재된 시간을 기준으로 교체할 캐시를 선정한다.\n단점: 오래 있었다는 이유로 독점될 가능성이 있음, 오래 있었지만 추후에 사용 안 할 수도 있다.</li>\n<li>LFU : 가장 적은 횟수를 참조하는 캐시를 교체\n단점: 추후에 자주 사용될 수 있지만 참조 수가 적다는 이유로 교체될 수 있다.</li>\n<li>LRU: 가장 오랫동안 참조되지 않은 페이지를 교체</li>\n</ul>\n<h3>3.4 LRU 알고리즘</h3>\n<hr>\n<p>Map 객체를 이용하여 간단하게 구현할 수 있다.</p>\n<deckgo-highlight-code language=\"jsx\" terminal=\"carbon\"  >\n          <code slot=\"code\">constructor(cacheSize) {\n        this.cacheSize = cacheSize;\n        this.cache = new Map();\n    }</code>\n        </deckgo-highlight-code>\n<deckgo-highlight-code language=\"jsx\" terminal=\"carbon\"  >\n          <code slot=\"code\">set(key, data) {\n        if (this.cache.size === this.cacheSize) {\n            this.cache.delete(this.cache.keys().next().value)\n        }\n        this.cache.set(keyword, sliced_data);\n    }</code>\n        </deckgo-highlight-code>\n<ul>\n<li>set 함수는 데이터 값을 캐시에 등록하는 함수 이다.</li>\n<li>우선 현재 캐시 사이즈가 꽉 차있는지 확인한다.\n<ul>\n<li>만약 캐시 사이즈가 초과된다면 캐시 값중 가장 맨 첫번째(가장 오래된)값을 삭제시킨다.</li>\n</ul>\n</li>\n<li>Map 객체는 순서를 보장하기 때문에 가능하다!</li>\n</ul>\n<deckgo-highlight-code language=\"jsx\" terminal=\"carbon\"  >\n          <code slot=\"code\">get(key) {\n        let data;\n        if (this.cache.has(key)) {\n            data = this.cache.get(key);\n\n            data.hitCount++;\n            this.cache.delete(key);\n            this.cache.set(key, data);\n        } else {\n            data = null;\n        }\n\n        return data;\n    }</code>\n        </deckgo-highlight-code>\n<ul>\n<li>get함수는 캐시 값을 가져오는 함수이다.</li>\n<li>우선 찾고자 하는 데이터가 있는지 확인한다.\n<ul>\n<li>만약 있다면 캐시 값을 그대로 가져오고 삭제 후 다시 넣어준다. (최신으로 갱신)</li>\n<li>만약 없다면 데이터에 널을 넣어 반환한다.</li>\n</ul>\n</li>\n</ul>\n<h3>3.5 LRU 캐시와 HashMap의 차이</h3>\n<hr>\n<p>일반적인 HashMap이라면 순서를 보장하지 않을 수 있다.</p>\n<p>순서를 보장하지 않는다면 위의 방식은 적합하지 않다.</p>\n<h3>⁉️ 그럼 순서를 보장하려면 어떻게 구현해야 할까??</h3>\n<ul>\n<li>Doubly Linked List(이중 연결 리스트)를 이용하여 구현할 수 있다.</li>\n<li>head를 정하고 head에 가까울 수록 최근 사용한 노드이고 tail에 가까우면 가장 오래 사용하지 않은 데이터로 구현할 수 있다.</li>\n</ul>\n<h4>‼️Doubly linked list란 무엇일까??</h4>\n<ul>\n<li><strong>양방향</strong> 연결리스트이다.</li>\n<li>일반 linked list는 단방향, 즉 next node만 가리키는 구조이다.</li>\n<li>반면에 doubly linked list란 previous, next 모두를 가리킨다!</li>\n</ul>\n<br />\n<img width=\"636\" alt=\"_2021-07-21__11 16 56\" src=\"https://user-images.githubusercontent.com/72444675/157589154-28fa4d87-86a3-4017-8605-6bdff311a538.png\">\n<p><a href=\"https://opentutorials.org/module/1335/8940\" target=\"_blank\" rel=\"nofollow\">출처: 생활코딩</a></p>\n<br />\n<h4>⁉️ 그래서 doubly linked list로 LRU를 어떻게 구현할 수 있는가?</h4>\n<ul>\n<li>위에서 만약 20에 다시 접근 했다면\n<ul>\n<li>20의 prev에 해당하는 노드와 20의 next에 해당하는 노드를 연결시켜준다.</li>\n<li>(10 &#x3C; - > 30 &#x3C; - > 40)</li>\n<li>20의 prev와 next를 각각 null, head를 가리키도록 한다.\n(20 &#x3C; - > 10 &#x3C; - > 30 &#x3C; - > 40)</li>\n<li>head가 20을 가리키도록 바꿔준다.</li>\n</ul>\n</li>\n<li>이렇게 구현한다면 head 에 가까울 수록 최신이고 tail에 가까울 수록 오래된 상태가 된다!</li>\n</ul>","frontmatter":{"title":"LRU","summary":"캐시가 무엇이고, LRU란 무엇인지 알아보자.","date":"2021.07.26.","categories":["CS"],"thumbnail":{"childImageSharp":{"gatsbyImageData":{"layout":"constrained","placeholder":{"fallback":"data:image/jpeg;base64,/9j/2wBDAAEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQH/2wBDAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQH/wgARCAAMABQDASIAAhEBAxEB/8QAGAAAAwEBAAAAAAAAAAAAAAAAAAgJAQf/xAAUAQEAAAAAAAAAAAAAAAAAAAAE/9oADAMBAAIQAxAAAAGmqJ2O4E8LQmgHf//EABsQAAICAwEAAAAAAAAAAAAAAAUGAAcBAgMW/9oACAEBAAEFArkbTqkLAuFk+ihEUOKYVk8Jz2n/xAAdEQACAgIDAQAAAAAAAAAAAAABAgMRBBIQISJR/9oACAEDAQE/AZ4cl5kaLIESWhdCpbZVNuo9AKWHW1NXzj//xAAeEQADAAEEAwAAAAAAAAAAAAABAgMEERITIQAiI//aAAgBAgEBPwHHyMScKJfENqFacdBQT2Oy6IzfNmdZn249ygnTsd6+f//EACQQAAICAQMDBQEAAAAAAAAAAAIDAQQFABITERQjBhAhIjEy/9oACAEBAAY/AsI/BWxpNvZSxXsN7WtaLgTi7luI6WluWtcNSDHtFLWigD4wmdYjPWvU8tx+VymDovx9iaxKsVcjmF0ZUGMDjVUmFOlqbCEoaIyDJ5CYYBpEZCoq12zZcjk3eNkrJZTG0h/oCkCieolE/Masschl1gXK9pRXGb+JwlybwFcKCfIsGeQT+4xMdPz2/8QAGhABAAMAAwAAAAAAAAAAAAAAAQARITGx0f/aAAgBAQABPyFSJXrjBiVSLMeD5QMLJkfYgx73DEHJBpbNUqEmUnxBN8Fjr4XELU//2gAMAwEAAgADAAAAEJ8P/8QAFxEAAwEAAAAAAAAAAAAAAAAAAREhAP/aAAgBAwEBPxAEsqDuhn48BNRb/8QAGBEBAQADAAAAAAAAAAAAAAAAAREQITH/2gAIAQIBAT8QCYhDiOinQKXJh//EABwQAQACAgMBAAAAAAAAAAAAAAEAEZGhITFRYf/aAAgBAQABPxC2EU9++HV5EJFZSrF897RGqrOfRhBohc3ElMOI+4Veou2jGPyoeyIxlV19ctu5/9k="},"images":{"fallback":{"src":"/static/7231dfd36025afc82790484ce5feec4b/b37b0/cs.jpg","srcSet":"/static/7231dfd36025afc82790484ce5feec4b/9cf2b/cs.jpg 250w,\n/static/7231dfd36025afc82790484ce5feec4b/3a8a8/cs.jpg 500w,\n/static/7231dfd36025afc82790484ce5feec4b/b37b0/cs.jpg 1000w","sizes":"(min-width: 1000px) 1000px, 100vw"},"sources":[{"srcSet":"/static/7231dfd36025afc82790484ce5feec4b/40603/cs.webp 250w,\n/static/7231dfd36025afc82790484ce5feec4b/7a96c/cs.webp 500w,\n/static/7231dfd36025afc82790484ce5feec4b/51449/cs.webp 1000w","type":"image/webp","sizes":"(min-width: 1000px) 1000px, 100vw"}]},"width":1000,"height":600}}}}}}]}},"pageContext":{"slug":"/LRU/"}},
    "staticQueryHashes": []}